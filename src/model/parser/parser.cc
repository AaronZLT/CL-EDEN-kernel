#include <unordered_map>
#include <future>
#include <iostream>

#include "model/parser/parser.hpp"
#include "model/parser/strategy/strategy.hpp"
#include "model/parser/strategy/nnc_parse_strategy.hpp"
#include "model/parser/strategy/cgo_parse_strategy.hpp"
#include "model/parser/strategy/coded_parse_strategy.hpp"
#include "common/helper_templates.hpp"
#include "common/enn_debug.h"

namespace enn {
namespace model {

// Implementation class for Pimpl
class Parser::Impl {
public:
    explicit Impl() = default;
    virtual ~Impl() = default;

    void Set(const ModelType& model_type, const std::shared_ptr<ModelMemInfo> model,
             const std::shared_ptr<std::vector<std::shared_ptr<enn::model::ModelMemInfo>>> params) {
        switch (model_type) {
            case ModelType::NNC:
                parse_strategy = std::make_unique<NncParseStrategy>(model);
                break;
            case ModelType::CGO:
                parse_strategy = std::make_unique<CgoParseStrategy>(model, params);
                break;
            case ModelType::CODED:
                parse_strategy = std::make_unique<CodedParseStrategy>();
                break;
            case ModelType::NONE:
            default:
                ENN_ERR_PRINT("Not Supported model type : %d\n", (int)model_type);
                break;
        }

        if (parse_strategy != nullptr && parse_strategy->is_verified()) {
            hash_key = get_hashcode(model->va, model->size);
        }
    }

    // This function is main part which parses data from input and, converts and generates memory,
    // if needed, and then finally create RawModel(enn::model::raw::Model).
    // It is like template method for writing overall procedure, and concrete logic is in ParseStrategy.
    const std::shared_ptr<raw::Model> Parse() {
        if (parse_strategy == nullptr) {
            ENN_ERR_PRINT("Can't parse unsupported type !!\n");
            return nullptr;
        }

        if (!parse_strategy->is_verified()) {
            ENN_ERR_PRINT("Model data is not verified !!\n");
            return nullptr;
        }

        // Check if it already has it with key generated by hash function
        // Required, ToDo(empire.jung, 6/30): Enable it again if thread-safe is guaranteed.
        // if (model_cache.find(hash_key) != model_cache.end()) {
        //     return model_cache[hash_key];
        // }

        parse_strategy->pre_execute();

        // Nice to have, ToDo(empire.jung, TBD): Check thread configuration and optimal count
        auto opr_f = enn::util::RunAsync(&ParseStrategy::parse_operators, parse_strategy.get());
        auto fm_f = enn::util::RunAsync(&ParseStrategy::parse_tensors, parse_strategy.get());
        auto opt_f = enn::util::RunAsync(&ParseStrategy::parse_operator_options, parse_strategy.get());
        auto scal_f = enn::util::RunAsync(&ParseStrategy::parse_scalars, parse_strategy.get());
        auto reg_f = enn::util::RunAsync(&ParseStrategy::parse_regions, parse_strategy.get());
        auto buf_f = enn::util::RunAsync(&ParseStrategy::parse_buffers, parse_strategy.get());
        auto attr_f = enn::util::RunAsync(&ParseStrategy::parse_attribute, parse_strategy.get());
        auto copt_f = enn::util::RunAsync(&ParseStrategy::parse_control_option, parse_strategy.get());
        auto bin_f = enn::util::RunAsync(&ParseStrategy::parse_binaries, parse_strategy.get());
        auto param_f = enn::util::RunAsync(&ParseStrategy::parse_parameters, parse_strategy.get());
        auto grpi_f = enn::util::RunAsync(&ParseStrategy::parse_graph_infos, parse_strategy.get());

        opr_f.get();
        fm_f.get();
        opt_f.get();
        scal_f.get();
        reg_f.get();
        buf_f.get();
        attr_f.get();
        copt_f.get();
        bin_f.get();
        param_f.get();
        grpi_f.get();

        parse_strategy->post_execute();

#ifndef ENN_BUILD_RELEASE
        parse_strategy->print();
#endif

        model_cache[hash_key] = parse_strategy->result();

        return model_cache[hash_key];
    }

    void init_cache() {
        model_cache.clear();
    }

private:
    std::unique_ptr<ParseStrategy> parse_strategy;

    uint64_t hash_key = 0;
    std::unordered_map<uint64_t, std::shared_ptr<raw::Model>> model_cache;

    // Nice to have, ToDo(empire.jung, TBD): Change to use std::hash
    uint64_t get_hashcode(void* model_va, const uint32_t model_size) {
        uint64_t hash_code = 9973;

        int loop_size = (model_size > 102400) ? 102400 : model_size;

        for (int i = 0; i < loop_size; ++i) {
            hash_code = 127 * hash_code + static_cast<unsigned char*>(model_va)[i];
        }

        ENN_DBG_PRINT("Hash code : 0x%" PRIx64 "\n", hash_code);

        return hash_code;
    }
};

Parser::Parser() : impl_(std::make_unique<Impl>()) {
    impl_->init_cache();
}

Parser::~Parser() {
    impl_->init_cache();
}

void Parser::Set(const ModelType& model_type, const std::shared_ptr<ModelMemInfo> model,
                 const std::shared_ptr<std::vector<std::shared_ptr<enn::model::ModelMemInfo>>> params) {
    impl_->Set(model_type, model, params);
}

std::shared_ptr<raw::Model> Parser::Parse() {
    return impl_->Parse();
}

};  // namespace model
};  // namespace enn
