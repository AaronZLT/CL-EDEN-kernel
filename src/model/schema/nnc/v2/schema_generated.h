// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_V2_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_V2_H_

#include "model/schema/flatbuffers/flatbuffers.h"

namespace tflite {
namespace v2 {

struct CustomQuantization;

struct QuantizationParameters;

struct SymmPerChannelQuantParamters;

struct Int32Vector;

struct Uint16Vector;

struct Uint8Vector;

struct DimensionMetadata;

struct SparsityParameters;

struct Tensor;

struct Conv2DOptions;

struct Conv3DOptions;

struct Pool2DOptions;

struct DepthwiseConv2DOptions;

struct ConcatEmbeddingsOptions;

struct LSHProjectionOptions;

struct SVDFOptions;

struct RNNOptions;

struct SequenceRNNOptions;

struct BidirectionalSequenceRNNOptions;

struct FullyConnectedOptions;

struct SoftmaxOptions;

struct ConcatenationOptions;

struct AddOptions;

struct MulOptions;

struct L2NormOptions;

struct LocalResponseNormalizationOptions;

struct LSTMOptions;

struct UnidirectionalSequenceLSTMOptions;

struct BidirectionalSequenceLSTMOptions;

struct ResizeBilinearOptions;

struct ResizeNearestNeighborOptions;

struct CallOptions;

struct PadOptions;

struct PadV2Options;

struct ReshapeOptions;

struct SpaceToBatchNDOptions;

struct BatchToSpaceNDOptions;

struct SkipGramOptions;

struct SpaceToDepthOptions;

struct DepthToSpaceOptions;

struct SubOptions;

struct DivOptions;

struct TopKV2Options;

struct EmbeddingLookupSparseOptions;

struct GatherOptions;

struct TransposeOptions;

struct ExpOptions;

struct CosOptions;

struct ReducerOptions;

struct SqueezeOptions;

struct SplitOptions;

struct SplitVOptions;

struct StridedSliceOptions;

struct LogSoftmaxOptions;

struct CastOptions;

struct DequantizeOptions;

struct MaximumMinimumOptions;

struct TileOptions;

struct ArgMaxOptions;

struct ArgMinOptions;

struct GreaterOptions;

struct GreaterEqualOptions;

struct LessOptions;

struct LessEqualOptions;

struct NegOptions;

struct SelectOptions;

struct SliceOptions;

struct TransposeConvOptions;

struct ExpandDimsOptions;

struct SparseToDenseOptions;

struct EqualOptions;

struct NotEqualOptions;

struct ShapeOptions;

struct RankOptions;

struct PowOptions;

struct FakeQuantOptions;

struct PackOptions;

struct LogicalOrOptions;

struct OneHotOptions;

struct AbsOptions;

struct HardSwishOptions;

struct LogicalAndOptions;

struct LogicalNotOptions;

struct UnpackOptions;

struct FloorDivOptions;

struct SquareOptions;

struct ZerosLikeOptions;

struct FillOptions;

struct FloorModOptions;

struct RangeOptions;

struct LeakyReluOptions;

struct SquaredDifferenceOptions;

struct MirrorPadOptions;

struct UniqueOptions;

struct ReverseV2Options;

struct AddNOptions;

struct GatherNdOptions;

struct WhereOptions;

struct ReverseSequenceOptions;

struct MatrixDiagOptions;

struct QuantizeOptions;

struct MatrixSetDiagOptions;

struct IfOptions;

struct CallOnceOptions;

struct WhileOptions;

struct NonMaxSuppressionV4Options;

struct NonMaxSuppressionV5Options;

struct ScatterNdOptions;

struct SelectV2Options;

struct DensifyOptions;

struct SegmentSumOptions;

struct BatchMatMulOptions;

struct CumsumOptions;

struct BroadcastToOptions;

struct Rfft2dOptions;

struct HashtableOptions;

struct HashtableFindOptions;

struct HashtableImportOptions;

struct HashtableSizeOptions;

struct ENN_FlattenOptions;

struct ENN_CropOptions;

struct ENN_PermuteOptions;

struct ENN_PriorBoxOptions;

struct ENN_DetectionOptions;

struct ENN_PowerOptions;

struct ENN_ScaleOptions;

struct ENN_TFliteDetectionOptions;

struct ENN_MeanOptions;

struct ENN_TFliteSliceOptions;

struct ENN_ReluOptions;

struct ENN_EluOptions;

struct ENN_ClipOptions;

struct ENN_CFUOptions;

struct ENN_InverseCFUOptions;

struct ENN_NormalizationOptions;

struct ENN_NPUOptions;

struct ENN_DSPOptions;

struct ENN_UNIFIED_DEVICE_BinaryOptions;

struct ENN_UNIFIED_DEVICEOptions;

struct OperatorCode;

struct Operator;

struct SubGraph;

struct Buffer;

struct Metadata;

struct TensorMap;

struct SignatureDef;

struct Model;

enum nnc {
  nnc_version = 201,
  nnc_MIN = nnc_version,
  nnc_MAX = nnc_version
};

inline const nnc (&EnumValuesnnc())[1] {
  static const nnc values[] = {
    nnc_version
  };
  return values;
}

inline const char * const *EnumNamesnnc() {
  static const char * const names[] = {
    "version",
    nullptr
  };
  return names;
}

inline const char *EnumNamennc(nnc e) {
  if (e < nnc_version || e > nnc_version) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(nnc_version);
  return EnumNamesnnc()[index];
}

enum TensorType {
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_FLOAT64 = 10,
  TensorType_COMPLEX128 = 11,
  TensorType_UINT64 = 12,
  TensorType_RESOURCE = 13,
  TensorType_VARIANT = 14,
  TensorType_UINT32 = 15,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_UINT32
};

inline const TensorType (&EnumValuesTensorType())[16] {
  static const TensorType values[] = {
    TensorType_FLOAT32,
    TensorType_FLOAT16,
    TensorType_INT32,
    TensorType_UINT8,
    TensorType_INT64,
    TensorType_STRING,
    TensorType_BOOL,
    TensorType_INT16,
    TensorType_COMPLEX64,
    TensorType_INT8,
    TensorType_FLOAT64,
    TensorType_COMPLEX128,
    TensorType_UINT64,
    TensorType_RESOURCE,
    TensorType_VARIANT,
    TensorType_UINT32
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    "FLOAT64",
    "COMPLEX128",
    "UINT64",
    "RESOURCE",
    "VARIANT",
    "UINT32",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  if (e < TensorType_FLOAT32 || e > TensorType_UINT32) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails {
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2] {
  static const QuantizationDetails values[] = {
    QuantizationDetails_NONE,
    QuantizationDetails_CustomQuantization
  };
  return values;
}

inline const char * const *EnumNamesQuantizationDetails() {
  static const char * const names[] = {
    "NONE",
    "CustomQuantization",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {
  if (e < QuantizationDetails_NONE || e > QuantizationDetails_CustomQuantization) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizationDetails()[index];
}

template<typename T> struct QuantizationDetailsTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template<> struct QuantizationDetailsTraits<CustomQuantization> {
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);
bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum DimensionType {
  DimensionType_DENSE = 0,
  DimensionType_SPARSE_CSR = 1,
  DimensionType_MIN = DimensionType_DENSE,
  DimensionType_MAX = DimensionType_SPARSE_CSR
};

inline const DimensionType (&EnumValuesDimensionType())[2] {
  static const DimensionType values[] = {
    DimensionType_DENSE,
    DimensionType_SPARSE_CSR
  };
  return values;
}

inline const char * const *EnumNamesDimensionType() {
  static const char * const names[] = {
    "DENSE",
    "SPARSE_CSR",
    nullptr
  };
  return names;
}

inline const char *EnumNameDimensionType(DimensionType e) {
  if (e < DimensionType_DENSE || e > DimensionType_SPARSE_CSR) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDimensionType()[index];
}

enum SparseIndexVector {
  SparseIndexVector_NONE = 0,
  SparseIndexVector_Int32Vector = 1,
  SparseIndexVector_Uint16Vector = 2,
  SparseIndexVector_Uint8Vector = 3,
  SparseIndexVector_MIN = SparseIndexVector_NONE,
  SparseIndexVector_MAX = SparseIndexVector_Uint8Vector
};

inline const SparseIndexVector (&EnumValuesSparseIndexVector())[4] {
  static const SparseIndexVector values[] = {
    SparseIndexVector_NONE,
    SparseIndexVector_Int32Vector,
    SparseIndexVector_Uint16Vector,
    SparseIndexVector_Uint8Vector
  };
  return values;
}

inline const char * const *EnumNamesSparseIndexVector() {
  static const char * const names[] = {
    "NONE",
    "Int32Vector",
    "Uint16Vector",
    "Uint8Vector",
    nullptr
  };
  return names;
}

inline const char *EnumNameSparseIndexVector(SparseIndexVector e) {
  if (e < SparseIndexVector_NONE || e > SparseIndexVector_Uint8Vector) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseIndexVector()[index];
}

template<typename T> struct SparseIndexVectorTraits {
  static const SparseIndexVector enum_value = SparseIndexVector_NONE;
};

template<> struct SparseIndexVectorTraits<Int32Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Int32Vector;
};

template<> struct SparseIndexVectorTraits<Uint16Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint16Vector;
};

template<> struct SparseIndexVectorTraits<Uint8Vector> {
  static const SparseIndexVector enum_value = SparseIndexVector_Uint8Vector;
};

bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type);
bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator {
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEPTH_TO_SPACE = 5,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MATRIX_DIAG = 113,
  BuiltinOperator_QUANTIZE = 114,
  BuiltinOperator_MATRIX_SET_DIAG = 115,
  BuiltinOperator_ROUND = 116,
  BuiltinOperator_HARD_SWISH = 117,
  BuiltinOperator_IF = 118,
  BuiltinOperator_WHILE = 119,
  BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
  BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
  BuiltinOperator_SCATTER_ND = 122,
  BuiltinOperator_SELECT_V2 = 123,
  BuiltinOperator_DENSIFY = 124,
  BuiltinOperator_SEGMENT_SUM = 125,
  BuiltinOperator_BATCH_MATMUL = 126,
  BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  BuiltinOperator_CUMSUM = 128,
  BuiltinOperator_CALL_ONCE = 129,
  BuiltinOperator_BROADCAST_TO = 130,
  BuiltinOperator_RFFT2D = 131,
  BuiltinOperator_CONV_3D = 132,
  BuiltinOperator_IMAG = 133,
  BuiltinOperator_REAL = 134,
  BuiltinOperator_COMPLEX_ABS = 135,
  BuiltinOperator_HASHTABLE = 136,
  BuiltinOperator_HASHTABLE_FIND = 137,
  BuiltinOperator_HASHTABLE_IMPORT = 138,
  BuiltinOperator_HASHTABLE_SIZE = 139,
  BuiltinOperator_ENN_CROP = 1000,
  BuiltinOperator_ENN_FLATTEN = 1001,
  BuiltinOperator_ENN_PERMUTE = 1002,
  BuiltinOperator_ENN_PRIORBOX = 1003,
  BuiltinOperator_ENN_DETECTION = 1004,
  BuiltinOperator_ENN_POWER = 1005,
  BuiltinOperator_ENN_SCALE = 1006,
  BuiltinOperator_ENN_TFLITE_DETECTION = 1007,
  BuiltinOperator_ENN_TFLITE_SLICE = 1008,
  BuiltinOperator_ENN_CLIP = 1009,
  BuiltinOperator_ENN_CFU = 1010,
  BuiltinOperator_ENN_INVERSE_CFU = 1011,
  BuiltinOperator_ENN_NORMALIZATION = 1012,
  BuiltinOperator_ENN_NPU = 1013,
  BuiltinOperator_ENN_DSP = 1014,
  BuiltinOperator_ENN_UNIFIED_DEVICE = 1015,
  BuiltinOperator_MIN = BuiltinOperator_ADD,
  BuiltinOperator_MAX = BuiltinOperator_ENN_UNIFIED_DEVICE
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[156] {
  static const BuiltinOperator values[] = {
    BuiltinOperator_ADD,
    BuiltinOperator_AVERAGE_POOL_2D,
    BuiltinOperator_CONCATENATION,
    BuiltinOperator_CONV_2D,
    BuiltinOperator_DEPTHWISE_CONV_2D,
    BuiltinOperator_DEPTH_TO_SPACE,
    BuiltinOperator_DEQUANTIZE,
    BuiltinOperator_EMBEDDING_LOOKUP,
    BuiltinOperator_FLOOR,
    BuiltinOperator_FULLY_CONNECTED,
    BuiltinOperator_HASHTABLE_LOOKUP,
    BuiltinOperator_L2_NORMALIZATION,
    BuiltinOperator_L2_POOL_2D,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
    BuiltinOperator_LOGISTIC,
    BuiltinOperator_LSH_PROJECTION,
    BuiltinOperator_LSTM,
    BuiltinOperator_MAX_POOL_2D,
    BuiltinOperator_MUL,
    BuiltinOperator_RELU,
    BuiltinOperator_RELU_N1_TO_1,
    BuiltinOperator_RELU6,
    BuiltinOperator_RESHAPE,
    BuiltinOperator_RESIZE_BILINEAR,
    BuiltinOperator_RNN,
    BuiltinOperator_SOFTMAX,
    BuiltinOperator_SPACE_TO_DEPTH,
    BuiltinOperator_SVDF,
    BuiltinOperator_TANH,
    BuiltinOperator_CONCAT_EMBEDDINGS,
    BuiltinOperator_SKIP_GRAM,
    BuiltinOperator_CALL,
    BuiltinOperator_CUSTOM,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
    BuiltinOperator_PAD,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_GATHER,
    BuiltinOperator_BATCH_TO_SPACE_ND,
    BuiltinOperator_SPACE_TO_BATCH_ND,
    BuiltinOperator_TRANSPOSE,
    BuiltinOperator_MEAN,
    BuiltinOperator_SUB,
    BuiltinOperator_DIV,
    BuiltinOperator_SQUEEZE,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_STRIDED_SLICE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_EXP,
    BuiltinOperator_TOPK_V2,
    BuiltinOperator_SPLIT,
    BuiltinOperator_LOG_SOFTMAX,
    BuiltinOperator_DELEGATE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_CAST,
    BuiltinOperator_PRELU,
    BuiltinOperator_MAXIMUM,
    BuiltinOperator_ARG_MAX,
    BuiltinOperator_MINIMUM,
    BuiltinOperator_LESS,
    BuiltinOperator_NEG,
    BuiltinOperator_PADV2,
    BuiltinOperator_GREATER,
    BuiltinOperator_GREATER_EQUAL,
    BuiltinOperator_LESS_EQUAL,
    BuiltinOperator_SELECT,
    BuiltinOperator_SLICE,
    BuiltinOperator_SIN,
    BuiltinOperator_TRANSPOSE_CONV,
    BuiltinOperator_SPARSE_TO_DENSE,
    BuiltinOperator_TILE,
    BuiltinOperator_EXPAND_DIMS,
    BuiltinOperator_EQUAL,
    BuiltinOperator_NOT_EQUAL,
    BuiltinOperator_LOG,
    BuiltinOperator_SUM,
    BuiltinOperator_SQRT,
    BuiltinOperator_RSQRT,
    BuiltinOperator_SHAPE,
    BuiltinOperator_POW,
    BuiltinOperator_ARG_MIN,
    BuiltinOperator_FAKE_QUANT,
    BuiltinOperator_REDUCE_PROD,
    BuiltinOperator_REDUCE_MAX,
    BuiltinOperator_PACK,
    BuiltinOperator_LOGICAL_OR,
    BuiltinOperator_ONE_HOT,
    BuiltinOperator_LOGICAL_AND,
    BuiltinOperator_LOGICAL_NOT,
    BuiltinOperator_UNPACK,
    BuiltinOperator_REDUCE_MIN,
    BuiltinOperator_FLOOR_DIV,
    BuiltinOperator_REDUCE_ANY,
    BuiltinOperator_SQUARE,
    BuiltinOperator_ZEROS_LIKE,
    BuiltinOperator_FILL,
    BuiltinOperator_FLOOR_MOD,
    BuiltinOperator_RANGE,
    BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
    BuiltinOperator_LEAKY_RELU,
    BuiltinOperator_SQUARED_DIFFERENCE,
    BuiltinOperator_MIRROR_PAD,
    BuiltinOperator_ABS,
    BuiltinOperator_SPLIT_V,
    BuiltinOperator_UNIQUE,
    BuiltinOperator_CEIL,
    BuiltinOperator_REVERSE_V2,
    BuiltinOperator_ADD_N,
    BuiltinOperator_GATHER_ND,
    BuiltinOperator_COS,
    BuiltinOperator_WHERE,
    BuiltinOperator_RANK,
    BuiltinOperator_ELU,
    BuiltinOperator_REVERSE_SEQUENCE,
    BuiltinOperator_MATRIX_DIAG,
    BuiltinOperator_QUANTIZE,
    BuiltinOperator_MATRIX_SET_DIAG,
    BuiltinOperator_ROUND,
    BuiltinOperator_HARD_SWISH,
    BuiltinOperator_IF,
    BuiltinOperator_WHILE,
    BuiltinOperator_NON_MAX_SUPPRESSION_V4,
    BuiltinOperator_NON_MAX_SUPPRESSION_V5,
    BuiltinOperator_SCATTER_ND,
    BuiltinOperator_SELECT_V2,
    BuiltinOperator_DENSIFY,
    BuiltinOperator_SEGMENT_SUM,
    BuiltinOperator_BATCH_MATMUL,
    BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES,
    BuiltinOperator_CUMSUM,
    BuiltinOperator_CALL_ONCE,
    BuiltinOperator_BROADCAST_TO,
    BuiltinOperator_RFFT2D,
    BuiltinOperator_CONV_3D,
    BuiltinOperator_IMAG,
    BuiltinOperator_REAL,
    BuiltinOperator_COMPLEX_ABS,
    BuiltinOperator_HASHTABLE,
    BuiltinOperator_HASHTABLE_FIND,
    BuiltinOperator_HASHTABLE_IMPORT,
    BuiltinOperator_HASHTABLE_SIZE,
    BuiltinOperator_ENN_CROP,
    BuiltinOperator_ENN_FLATTEN,
    BuiltinOperator_ENN_PERMUTE,
    BuiltinOperator_ENN_PRIORBOX,
    BuiltinOperator_ENN_DETECTION,
    BuiltinOperator_ENN_POWER,
    BuiltinOperator_ENN_SCALE,
    BuiltinOperator_ENN_TFLITE_DETECTION,
    BuiltinOperator_ENN_TFLITE_SLICE,
    BuiltinOperator_ENN_CLIP,
    BuiltinOperator_ENN_CFU,
    BuiltinOperator_ENN_INVERSE_CFU,
    BuiltinOperator_ENN_NORMALIZATION,
    BuiltinOperator_ENN_NPU,
    BuiltinOperator_ENN_DSP,
    BuiltinOperator_ENN_UNIFIED_DEVICE
  };
  return values;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
  switch (e) {
    case BuiltinOperator_ADD: return "ADD";
    case BuiltinOperator_AVERAGE_POOL_2D: return "AVERAGE_POOL_2D";
    case BuiltinOperator_CONCATENATION: return "CONCATENATION";
    case BuiltinOperator_CONV_2D: return "CONV_2D";
    case BuiltinOperator_DEPTHWISE_CONV_2D: return "DEPTHWISE_CONV_2D";
    case BuiltinOperator_DEPTH_TO_SPACE: return "DEPTH_TO_SPACE";
    case BuiltinOperator_DEQUANTIZE: return "DEQUANTIZE";
    case BuiltinOperator_EMBEDDING_LOOKUP: return "EMBEDDING_LOOKUP";
    case BuiltinOperator_FLOOR: return "FLOOR";
    case BuiltinOperator_FULLY_CONNECTED: return "FULLY_CONNECTED";
    case BuiltinOperator_HASHTABLE_LOOKUP: return "HASHTABLE_LOOKUP";
    case BuiltinOperator_L2_NORMALIZATION: return "L2_NORMALIZATION";
    case BuiltinOperator_L2_POOL_2D: return "L2_POOL_2D";
    case BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION: return "LOCAL_RESPONSE_NORMALIZATION";
    case BuiltinOperator_LOGISTIC: return "LOGISTIC";
    case BuiltinOperator_LSH_PROJECTION: return "LSH_PROJECTION";
    case BuiltinOperator_LSTM: return "LSTM";
    case BuiltinOperator_MAX_POOL_2D: return "MAX_POOL_2D";
    case BuiltinOperator_MUL: return "MUL";
    case BuiltinOperator_RELU: return "RELU";
    case BuiltinOperator_RELU_N1_TO_1: return "RELU_N1_TO_1";
    case BuiltinOperator_RELU6: return "RELU6";
    case BuiltinOperator_RESHAPE: return "RESHAPE";
    case BuiltinOperator_RESIZE_BILINEAR: return "RESIZE_BILINEAR";
    case BuiltinOperator_RNN: return "RNN";
    case BuiltinOperator_SOFTMAX: return "SOFTMAX";
    case BuiltinOperator_SPACE_TO_DEPTH: return "SPACE_TO_DEPTH";
    case BuiltinOperator_SVDF: return "SVDF";
    case BuiltinOperator_TANH: return "TANH";
    case BuiltinOperator_CONCAT_EMBEDDINGS: return "CONCAT_EMBEDDINGS";
    case BuiltinOperator_SKIP_GRAM: return "SKIP_GRAM";
    case BuiltinOperator_CALL: return "CALL";
    case BuiltinOperator_CUSTOM: return "CUSTOM";
    case BuiltinOperator_EMBEDDING_LOOKUP_SPARSE: return "EMBEDDING_LOOKUP_SPARSE";
    case BuiltinOperator_PAD: return "PAD";
    case BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN: return "UNIDIRECTIONAL_SEQUENCE_RNN";
    case BuiltinOperator_GATHER: return "GATHER";
    case BuiltinOperator_BATCH_TO_SPACE_ND: return "BATCH_TO_SPACE_ND";
    case BuiltinOperator_SPACE_TO_BATCH_ND: return "SPACE_TO_BATCH_ND";
    case BuiltinOperator_TRANSPOSE: return "TRANSPOSE";
    case BuiltinOperator_MEAN: return "MEAN";
    case BuiltinOperator_SUB: return "SUB";
    case BuiltinOperator_DIV: return "DIV";
    case BuiltinOperator_SQUEEZE: return "SQUEEZE";
    case BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM: return "UNIDIRECTIONAL_SEQUENCE_LSTM";
    case BuiltinOperator_STRIDED_SLICE: return "STRIDED_SLICE";
    case BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN: return "BIDIRECTIONAL_SEQUENCE_RNN";
    case BuiltinOperator_EXP: return "EXP";
    case BuiltinOperator_TOPK_V2: return "TOPK_V2";
    case BuiltinOperator_SPLIT: return "SPLIT";
    case BuiltinOperator_LOG_SOFTMAX: return "LOG_SOFTMAX";
    case BuiltinOperator_DELEGATE: return "DELEGATE";
    case BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM: return "BIDIRECTIONAL_SEQUENCE_LSTM";
    case BuiltinOperator_CAST: return "CAST";
    case BuiltinOperator_PRELU: return "PRELU";
    case BuiltinOperator_MAXIMUM: return "MAXIMUM";
    case BuiltinOperator_ARG_MAX: return "ARG_MAX";
    case BuiltinOperator_MINIMUM: return "MINIMUM";
    case BuiltinOperator_LESS: return "LESS";
    case BuiltinOperator_NEG: return "NEG";
    case BuiltinOperator_PADV2: return "PADV2";
    case BuiltinOperator_GREATER: return "GREATER";
    case BuiltinOperator_GREATER_EQUAL: return "GREATER_EQUAL";
    case BuiltinOperator_LESS_EQUAL: return "LESS_EQUAL";
    case BuiltinOperator_SELECT: return "SELECT";
    case BuiltinOperator_SLICE: return "SLICE";
    case BuiltinOperator_SIN: return "SIN";
    case BuiltinOperator_TRANSPOSE_CONV: return "TRANSPOSE_CONV";
    case BuiltinOperator_SPARSE_TO_DENSE: return "SPARSE_TO_DENSE";
    case BuiltinOperator_TILE: return "TILE";
    case BuiltinOperator_EXPAND_DIMS: return "EXPAND_DIMS";
    case BuiltinOperator_EQUAL: return "EQUAL";
    case BuiltinOperator_NOT_EQUAL: return "NOT_EQUAL";
    case BuiltinOperator_LOG: return "LOG";
    case BuiltinOperator_SUM: return "SUM";
    case BuiltinOperator_SQRT: return "SQRT";
    case BuiltinOperator_RSQRT: return "RSQRT";
    case BuiltinOperator_SHAPE: return "SHAPE";
    case BuiltinOperator_POW: return "POW";
    case BuiltinOperator_ARG_MIN: return "ARG_MIN";
    case BuiltinOperator_FAKE_QUANT: return "FAKE_QUANT";
    case BuiltinOperator_REDUCE_PROD: return "REDUCE_PROD";
    case BuiltinOperator_REDUCE_MAX: return "REDUCE_MAX";
    case BuiltinOperator_PACK: return "PACK";
    case BuiltinOperator_LOGICAL_OR: return "LOGICAL_OR";
    case BuiltinOperator_ONE_HOT: return "ONE_HOT";
    case BuiltinOperator_LOGICAL_AND: return "LOGICAL_AND";
    case BuiltinOperator_LOGICAL_NOT: return "LOGICAL_NOT";
    case BuiltinOperator_UNPACK: return "UNPACK";
    case BuiltinOperator_REDUCE_MIN: return "REDUCE_MIN";
    case BuiltinOperator_FLOOR_DIV: return "FLOOR_DIV";
    case BuiltinOperator_REDUCE_ANY: return "REDUCE_ANY";
    case BuiltinOperator_SQUARE: return "SQUARE";
    case BuiltinOperator_ZEROS_LIKE: return "ZEROS_LIKE";
    case BuiltinOperator_FILL: return "FILL";
    case BuiltinOperator_FLOOR_MOD: return "FLOOR_MOD";
    case BuiltinOperator_RANGE: return "RANGE";
    case BuiltinOperator_RESIZE_NEAREST_NEIGHBOR: return "RESIZE_NEAREST_NEIGHBOR";
    case BuiltinOperator_LEAKY_RELU: return "LEAKY_RELU";
    case BuiltinOperator_SQUARED_DIFFERENCE: return "SQUARED_DIFFERENCE";
    case BuiltinOperator_MIRROR_PAD: return "MIRROR_PAD";
    case BuiltinOperator_ABS: return "ABS";
    case BuiltinOperator_SPLIT_V: return "SPLIT_V";
    case BuiltinOperator_UNIQUE: return "UNIQUE";
    case BuiltinOperator_CEIL: return "CEIL";
    case BuiltinOperator_REVERSE_V2: return "REVERSE_V2";
    case BuiltinOperator_ADD_N: return "ADD_N";
    case BuiltinOperator_GATHER_ND: return "GATHER_ND";
    case BuiltinOperator_COS: return "COS";
    case BuiltinOperator_WHERE: return "WHERE";
    case BuiltinOperator_RANK: return "RANK";
    case BuiltinOperator_ELU: return "ELU";
    case BuiltinOperator_REVERSE_SEQUENCE: return "REVERSE_SEQUENCE";
    case BuiltinOperator_MATRIX_DIAG: return "MATRIX_DIAG";
    case BuiltinOperator_QUANTIZE: return "QUANTIZE";
    case BuiltinOperator_MATRIX_SET_DIAG: return "MATRIX_SET_DIAG";
    case BuiltinOperator_ROUND: return "ROUND";
    case BuiltinOperator_HARD_SWISH: return "HARD_SWISH";
    case BuiltinOperator_IF: return "IF";
    case BuiltinOperator_WHILE: return "WHILE";
    case BuiltinOperator_NON_MAX_SUPPRESSION_V4: return "NON_MAX_SUPPRESSION_V4";
    case BuiltinOperator_NON_MAX_SUPPRESSION_V5: return "NON_MAX_SUPPRESSION_V5";
    case BuiltinOperator_SCATTER_ND: return "SCATTER_ND";
    case BuiltinOperator_SELECT_V2: return "SELECT_V2";
    case BuiltinOperator_DENSIFY: return "DENSIFY";
    case BuiltinOperator_SEGMENT_SUM: return "SEGMENT_SUM";
    case BuiltinOperator_BATCH_MATMUL: return "BATCH_MATMUL";
    case BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES: return "PLACEHOLDER_FOR_GREATER_OP_CODES";
    case BuiltinOperator_CUMSUM: return "CUMSUM";
    case BuiltinOperator_CALL_ONCE: return "CALL_ONCE";
    case BuiltinOperator_BROADCAST_TO: return "BROADCAST_TO";
    case BuiltinOperator_RFFT2D: return "RFFT2D";
    case BuiltinOperator_CONV_3D: return "CONV_3D";
    case BuiltinOperator_IMAG: return "IMAG";
    case BuiltinOperator_REAL: return "REAL";
    case BuiltinOperator_COMPLEX_ABS: return "COMPLEX_ABS";
    case BuiltinOperator_HASHTABLE: return "HASHTABLE";
    case BuiltinOperator_HASHTABLE_FIND: return "HASHTABLE_FIND";
    case BuiltinOperator_HASHTABLE_IMPORT: return "HASHTABLE_IMPORT";
    case BuiltinOperator_HASHTABLE_SIZE: return "HASHTABLE_SIZE";
    case BuiltinOperator_ENN_CROP: return "ENN_CROP";
    case BuiltinOperator_ENN_FLATTEN: return "ENN_FLATTEN";
    case BuiltinOperator_ENN_PERMUTE: return "ENN_PERMUTE";
    case BuiltinOperator_ENN_PRIORBOX: return "ENN_PRIORBOX";
    case BuiltinOperator_ENN_DETECTION: return "ENN_DETECTION";
    case BuiltinOperator_ENN_POWER: return "ENN_POWER";
    case BuiltinOperator_ENN_SCALE: return "ENN_SCALE";
    case BuiltinOperator_ENN_TFLITE_DETECTION: return "ENN_TFLITE_DETECTION";
    case BuiltinOperator_ENN_TFLITE_SLICE: return "ENN_TFLITE_SLICE";
    case BuiltinOperator_ENN_CLIP: return "ENN_CLIP";
    case BuiltinOperator_ENN_CFU: return "ENN_CFU";
    case BuiltinOperator_ENN_INVERSE_CFU: return "ENN_INVERSE_CFU";
    case BuiltinOperator_ENN_NORMALIZATION: return "ENN_NORMALIZATION";
    case BuiltinOperator_ENN_NPU: return "ENN_NPU";
    case BuiltinOperator_ENN_DSP: return "ENN_DSP";
    case BuiltinOperator_ENN_UNIFIED_DEVICE: return "ENN_UNIFIED_DEVICE";
    default: return "";
  }
}

enum BuiltinOptions {
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MatrixDiagOptions = 88,
  BuiltinOptions_QuantizeOptions = 89,
  BuiltinOptions_MatrixSetDiagOptions = 90,
  BuiltinOptions_HardSwishOptions = 91,
  BuiltinOptions_IfOptions = 92,
  BuiltinOptions_WhileOptions = 93,
  BuiltinOptions_DepthToSpaceOptions = 94,
  BuiltinOptions_NonMaxSuppressionV4Options = 95,
  BuiltinOptions_NonMaxSuppressionV5Options = 96,
  BuiltinOptions_ScatterNdOptions = 97,
  BuiltinOptions_SelectV2Options = 98,
  BuiltinOptions_DensifyOptions = 99,
  BuiltinOptions_SegmentSumOptions = 100,
  BuiltinOptions_BatchMatMulOptions = 101,
  BuiltinOptions_CumsumOptions = 102,
  BuiltinOptions_CallOnceOptions = 103,
  BuiltinOptions_BroadcastToOptions = 104,
  BuiltinOptions_Rfft2dOptions = 105,
  BuiltinOptions_Conv3DOptions = 106,
  BuiltinOptions_HashtableOptions = 107,
  BuiltinOptions_HashtableFindOptions = 108,
  BuiltinOptions_HashtableImportOptions = 109,
  BuiltinOptions_HashtableSizeOptions = 110,
  BuiltinOptions_ENN_FlattenOptions = 111,
  BuiltinOptions_ENN_CropOptions = 112,
  BuiltinOptions_ENN_PermuteOptions = 113,
  BuiltinOptions_ENN_PriorBoxOptions = 114,
  BuiltinOptions_ENN_DetectionOptions = 115,
  BuiltinOptions_ENN_PowerOptions = 116,
  BuiltinOptions_ENN_ScaleOptions = 117,
  BuiltinOptions_ENN_TFliteDetectionOptions = 118,
  BuiltinOptions_ENN_MeanOptions = 119,
  BuiltinOptions_ENN_TFliteSliceOptions = 120,
  BuiltinOptions_ENN_ReluOptions = 121,
  BuiltinOptions_ENN_EluOptions = 122,
  BuiltinOptions_ENN_ClipOptions = 123,
  BuiltinOptions_ENN_CFUOptions = 124,
  BuiltinOptions_ENN_InverseCFUOptions = 125,
  BuiltinOptions_ENN_NormalizationOptions = 126,
  BuiltinOptions_ENN_NPUOptions = 127,
  BuiltinOptions_ENN_DSPOptions = 128,
  BuiltinOptions_ENN_UNIFIED_DEVICEOptions = 129,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_ENN_UNIFIED_DEVICEOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[130] {
  static const BuiltinOptions values[] = {
    BuiltinOptions_NONE,
    BuiltinOptions_Conv2DOptions,
    BuiltinOptions_DepthwiseConv2DOptions,
    BuiltinOptions_ConcatEmbeddingsOptions,
    BuiltinOptions_LSHProjectionOptions,
    BuiltinOptions_Pool2DOptions,
    BuiltinOptions_SVDFOptions,
    BuiltinOptions_RNNOptions,
    BuiltinOptions_FullyConnectedOptions,
    BuiltinOptions_SoftmaxOptions,
    BuiltinOptions_ConcatenationOptions,
    BuiltinOptions_AddOptions,
    BuiltinOptions_L2NormOptions,
    BuiltinOptions_LocalResponseNormalizationOptions,
    BuiltinOptions_LSTMOptions,
    BuiltinOptions_ResizeBilinearOptions,
    BuiltinOptions_CallOptions,
    BuiltinOptions_ReshapeOptions,
    BuiltinOptions_SkipGramOptions,
    BuiltinOptions_SpaceToDepthOptions,
    BuiltinOptions_EmbeddingLookupSparseOptions,
    BuiltinOptions_MulOptions,
    BuiltinOptions_PadOptions,
    BuiltinOptions_GatherOptions,
    BuiltinOptions_BatchToSpaceNDOptions,
    BuiltinOptions_SpaceToBatchNDOptions,
    BuiltinOptions_TransposeOptions,
    BuiltinOptions_ReducerOptions,
    BuiltinOptions_SubOptions,
    BuiltinOptions_DivOptions,
    BuiltinOptions_SqueezeOptions,
    BuiltinOptions_SequenceRNNOptions,
    BuiltinOptions_StridedSliceOptions,
    BuiltinOptions_ExpOptions,
    BuiltinOptions_TopKV2Options,
    BuiltinOptions_SplitOptions,
    BuiltinOptions_LogSoftmaxOptions,
    BuiltinOptions_CastOptions,
    BuiltinOptions_DequantizeOptions,
    BuiltinOptions_MaximumMinimumOptions,
    BuiltinOptions_ArgMaxOptions,
    BuiltinOptions_LessOptions,
    BuiltinOptions_NegOptions,
    BuiltinOptions_PadV2Options,
    BuiltinOptions_GreaterOptions,
    BuiltinOptions_GreaterEqualOptions,
    BuiltinOptions_LessEqualOptions,
    BuiltinOptions_SelectOptions,
    BuiltinOptions_SliceOptions,
    BuiltinOptions_TransposeConvOptions,
    BuiltinOptions_SparseToDenseOptions,
    BuiltinOptions_TileOptions,
    BuiltinOptions_ExpandDimsOptions,
    BuiltinOptions_EqualOptions,
    BuiltinOptions_NotEqualOptions,
    BuiltinOptions_ShapeOptions,
    BuiltinOptions_PowOptions,
    BuiltinOptions_ArgMinOptions,
    BuiltinOptions_FakeQuantOptions,
    BuiltinOptions_PackOptions,
    BuiltinOptions_LogicalOrOptions,
    BuiltinOptions_OneHotOptions,
    BuiltinOptions_LogicalAndOptions,
    BuiltinOptions_LogicalNotOptions,
    BuiltinOptions_UnpackOptions,
    BuiltinOptions_FloorDivOptions,
    BuiltinOptions_SquareOptions,
    BuiltinOptions_ZerosLikeOptions,
    BuiltinOptions_FillOptions,
    BuiltinOptions_BidirectionalSequenceLSTMOptions,
    BuiltinOptions_BidirectionalSequenceRNNOptions,
    BuiltinOptions_UnidirectionalSequenceLSTMOptions,
    BuiltinOptions_FloorModOptions,
    BuiltinOptions_RangeOptions,
    BuiltinOptions_ResizeNearestNeighborOptions,
    BuiltinOptions_LeakyReluOptions,
    BuiltinOptions_SquaredDifferenceOptions,
    BuiltinOptions_MirrorPadOptions,
    BuiltinOptions_AbsOptions,
    BuiltinOptions_SplitVOptions,
    BuiltinOptions_UniqueOptions,
    BuiltinOptions_ReverseV2Options,
    BuiltinOptions_AddNOptions,
    BuiltinOptions_GatherNdOptions,
    BuiltinOptions_CosOptions,
    BuiltinOptions_WhereOptions,
    BuiltinOptions_RankOptions,
    BuiltinOptions_ReverseSequenceOptions,
    BuiltinOptions_MatrixDiagOptions,
    BuiltinOptions_QuantizeOptions,
    BuiltinOptions_MatrixSetDiagOptions,
    BuiltinOptions_HardSwishOptions,
    BuiltinOptions_IfOptions,
    BuiltinOptions_WhileOptions,
    BuiltinOptions_DepthToSpaceOptions,
    BuiltinOptions_NonMaxSuppressionV4Options,
    BuiltinOptions_NonMaxSuppressionV5Options,
    BuiltinOptions_ScatterNdOptions,
    BuiltinOptions_SelectV2Options,
    BuiltinOptions_DensifyOptions,
    BuiltinOptions_SegmentSumOptions,
    BuiltinOptions_BatchMatMulOptions,
    BuiltinOptions_CumsumOptions,
    BuiltinOptions_CallOnceOptions,
    BuiltinOptions_BroadcastToOptions,
    BuiltinOptions_Rfft2dOptions,
    BuiltinOptions_Conv3DOptions,
    BuiltinOptions_HashtableOptions,
    BuiltinOptions_HashtableFindOptions,
    BuiltinOptions_HashtableImportOptions,
    BuiltinOptions_HashtableSizeOptions,
    BuiltinOptions_ENN_FlattenOptions,
    BuiltinOptions_ENN_CropOptions,
    BuiltinOptions_ENN_PermuteOptions,
    BuiltinOptions_ENN_PriorBoxOptions,
    BuiltinOptions_ENN_DetectionOptions,
    BuiltinOptions_ENN_PowerOptions,
    BuiltinOptions_ENN_ScaleOptions,
    BuiltinOptions_ENN_TFliteDetectionOptions,
    BuiltinOptions_ENN_MeanOptions,
    BuiltinOptions_ENN_TFliteSliceOptions,
    BuiltinOptions_ENN_ReluOptions,
    BuiltinOptions_ENN_EluOptions,
    BuiltinOptions_ENN_ClipOptions,
    BuiltinOptions_ENN_CFUOptions,
    BuiltinOptions_ENN_InverseCFUOptions,
    BuiltinOptions_ENN_NormalizationOptions,
    BuiltinOptions_ENN_NPUOptions,
    BuiltinOptions_ENN_DSPOptions,
    BuiltinOptions_ENN_UNIFIED_DEVICEOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions() {
  static const char * const names[] = {
    "NONE",
    "Conv2DOptions",
    "DepthwiseConv2DOptions",
    "ConcatEmbeddingsOptions",
    "LSHProjectionOptions",
    "Pool2DOptions",
    "SVDFOptions",
    "RNNOptions",
    "FullyConnectedOptions",
    "SoftmaxOptions",
    "ConcatenationOptions",
    "AddOptions",
    "L2NormOptions",
    "LocalResponseNormalizationOptions",
    "LSTMOptions",
    "ResizeBilinearOptions",
    "CallOptions",
    "ReshapeOptions",
    "SkipGramOptions",
    "SpaceToDepthOptions",
    "EmbeddingLookupSparseOptions",
    "MulOptions",
    "PadOptions",
    "GatherOptions",
    "BatchToSpaceNDOptions",
    "SpaceToBatchNDOptions",
    "TransposeOptions",
    "ReducerOptions",
    "SubOptions",
    "DivOptions",
    "SqueezeOptions",
    "SequenceRNNOptions",
    "StridedSliceOptions",
    "ExpOptions",
    "TopKV2Options",
    "SplitOptions",
    "LogSoftmaxOptions",
    "CastOptions",
    "DequantizeOptions",
    "MaximumMinimumOptions",
    "ArgMaxOptions",
    "LessOptions",
    "NegOptions",
    "PadV2Options",
    "GreaterOptions",
    "GreaterEqualOptions",
    "LessEqualOptions",
    "SelectOptions",
    "SliceOptions",
    "TransposeConvOptions",
    "SparseToDenseOptions",
    "TileOptions",
    "ExpandDimsOptions",
    "EqualOptions",
    "NotEqualOptions",
    "ShapeOptions",
    "PowOptions",
    "ArgMinOptions",
    "FakeQuantOptions",
    "PackOptions",
    "LogicalOrOptions",
    "OneHotOptions",
    "LogicalAndOptions",
    "LogicalNotOptions",
    "UnpackOptions",
    "FloorDivOptions",
    "SquareOptions",
    "ZerosLikeOptions",
    "FillOptions",
    "BidirectionalSequenceLSTMOptions",
    "BidirectionalSequenceRNNOptions",
    "UnidirectionalSequenceLSTMOptions",
    "FloorModOptions",
    "RangeOptions",
    "ResizeNearestNeighborOptions",
    "LeakyReluOptions",
    "SquaredDifferenceOptions",
    "MirrorPadOptions",
    "AbsOptions",
    "SplitVOptions",
    "UniqueOptions",
    "ReverseV2Options",
    "AddNOptions",
    "GatherNdOptions",
    "CosOptions",
    "WhereOptions",
    "RankOptions",
    "ReverseSequenceOptions",
    "MatrixDiagOptions",
    "QuantizeOptions",
    "MatrixSetDiagOptions",
    "HardSwishOptions",
    "IfOptions",
    "WhileOptions",
    "DepthToSpaceOptions",
    "NonMaxSuppressionV4Options",
    "NonMaxSuppressionV5Options",
    "ScatterNdOptions",
    "SelectV2Options",
    "DensifyOptions",
    "SegmentSumOptions",
    "BatchMatMulOptions",
    "CumsumOptions",
    "CallOnceOptions",
    "BroadcastToOptions",
    "Rfft2dOptions",
    "Conv3DOptions",
    "HashtableOptions",
    "HashtableFindOptions",
    "HashtableImportOptions",
    "HashtableSizeOptions",
    "ENN_FlattenOptions",
    "ENN_CropOptions",
    "ENN_PermuteOptions",
    "ENN_PriorBoxOptions",
    "ENN_DetectionOptions",
    "ENN_PowerOptions",
    "ENN_ScaleOptions",
    "ENN_TFliteDetectionOptions",
    "ENN_MeanOptions",
    "ENN_TFliteSliceOptions",
    "ENN_ReluOptions",
    "ENN_EluOptions",
    "ENN_ClipOptions",
    "ENN_CFUOptions",
    "ENN_InverseCFUOptions",
    "ENN_NormalizationOptions",
    "ENN_NPUOptions",
    "ENN_DSPOptions",
    "ENN_UNIFIED_DEVICEOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
  if (e < BuiltinOptions_NONE || e > BuiltinOptions_ENN_UNIFIED_DEVICEOptions) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBuiltinOptions()[index];
}

template<typename T> struct BuiltinOptionsTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template<> struct BuiltinOptionsTraits<Conv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template<> struct BuiltinOptionsTraits<DepthwiseConv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template<> struct BuiltinOptionsTraits<ConcatEmbeddingsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template<> struct BuiltinOptionsTraits<LSHProjectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template<> struct BuiltinOptionsTraits<Pool2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template<> struct BuiltinOptionsTraits<SVDFOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template<> struct BuiltinOptionsTraits<RNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template<> struct BuiltinOptionsTraits<FullyConnectedOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template<> struct BuiltinOptionsTraits<SoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<ConcatenationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template<> struct BuiltinOptionsTraits<AddOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template<> struct BuiltinOptionsTraits<L2NormOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template<> struct BuiltinOptionsTraits<LocalResponseNormalizationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template<> struct BuiltinOptionsTraits<LSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template<> struct BuiltinOptionsTraits<ResizeBilinearOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template<> struct BuiltinOptionsTraits<CallOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template<> struct BuiltinOptionsTraits<ReshapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template<> struct BuiltinOptionsTraits<SkipGramOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template<> struct BuiltinOptionsTraits<SpaceToDepthOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template<> struct BuiltinOptionsTraits<EmbeddingLookupSparseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template<> struct BuiltinOptionsTraits<MulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template<> struct BuiltinOptionsTraits<PadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template<> struct BuiltinOptionsTraits<GatherOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template<> struct BuiltinOptionsTraits<BatchToSpaceNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template<> struct BuiltinOptionsTraits<SpaceToBatchNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template<> struct BuiltinOptionsTraits<TransposeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template<> struct BuiltinOptionsTraits<ReducerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template<> struct BuiltinOptionsTraits<SubOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template<> struct BuiltinOptionsTraits<DivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template<> struct BuiltinOptionsTraits<SqueezeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template<> struct BuiltinOptionsTraits<SequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<StridedSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template<> struct BuiltinOptionsTraits<ExpOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template<> struct BuiltinOptionsTraits<TopKV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template<> struct BuiltinOptionsTraits<SplitOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template<> struct BuiltinOptionsTraits<LogSoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<CastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template<> struct BuiltinOptionsTraits<DequantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template<> struct BuiltinOptionsTraits<MaximumMinimumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template<> struct BuiltinOptionsTraits<ArgMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template<> struct BuiltinOptionsTraits<LessOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template<> struct BuiltinOptionsTraits<NegOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template<> struct BuiltinOptionsTraits<PadV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template<> struct BuiltinOptionsTraits<GreaterOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template<> struct BuiltinOptionsTraits<GreaterEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template<> struct BuiltinOptionsTraits<LessEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template<> struct BuiltinOptionsTraits<SelectOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template<> struct BuiltinOptionsTraits<SliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template<> struct BuiltinOptionsTraits<TransposeConvOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template<> struct BuiltinOptionsTraits<SparseToDenseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template<> struct BuiltinOptionsTraits<TileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template<> struct BuiltinOptionsTraits<ExpandDimsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template<> struct BuiltinOptionsTraits<EqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template<> struct BuiltinOptionsTraits<NotEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template<> struct BuiltinOptionsTraits<ShapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template<> struct BuiltinOptionsTraits<PowOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template<> struct BuiltinOptionsTraits<ArgMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template<> struct BuiltinOptionsTraits<FakeQuantOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template<> struct BuiltinOptionsTraits<PackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template<> struct BuiltinOptionsTraits<LogicalOrOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template<> struct BuiltinOptionsTraits<OneHotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template<> struct BuiltinOptionsTraits<LogicalAndOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template<> struct BuiltinOptionsTraits<LogicalNotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template<> struct BuiltinOptionsTraits<UnpackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template<> struct BuiltinOptionsTraits<FloorDivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template<> struct BuiltinOptionsTraits<SquareOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template<> struct BuiltinOptionsTraits<ZerosLikeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template<> struct BuiltinOptionsTraits<FillOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template<> struct BuiltinOptionsTraits<BidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<BidirectionalSequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<UnidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<FloorModOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template<> struct BuiltinOptionsTraits<RangeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template<> struct BuiltinOptionsTraits<ResizeNearestNeighborOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template<> struct BuiltinOptionsTraits<LeakyReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template<> struct BuiltinOptionsTraits<SquaredDifferenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template<> struct BuiltinOptionsTraits<MirrorPadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template<> struct BuiltinOptionsTraits<AbsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template<> struct BuiltinOptionsTraits<SplitVOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template<> struct BuiltinOptionsTraits<UniqueOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template<> struct BuiltinOptionsTraits<ReverseV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template<> struct BuiltinOptionsTraits<AddNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template<> struct BuiltinOptionsTraits<GatherNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template<> struct BuiltinOptionsTraits<CosOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template<> struct BuiltinOptionsTraits<WhereOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template<> struct BuiltinOptionsTraits<RankOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template<> struct BuiltinOptionsTraits<ReverseSequenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

template<> struct BuiltinOptionsTraits<MatrixDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixDiagOptions;
};

template<> struct BuiltinOptionsTraits<QuantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_QuantizeOptions;
};

template<> struct BuiltinOptionsTraits<MatrixSetDiagOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MatrixSetDiagOptions;
};

template<> struct BuiltinOptionsTraits<HardSwishOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HardSwishOptions;
};

template<> struct BuiltinOptionsTraits<IfOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_IfOptions;
};

template<> struct BuiltinOptionsTraits<WhileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhileOptions;
};

template<> struct BuiltinOptionsTraits<DepthToSpaceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthToSpaceOptions;
};

template<> struct BuiltinOptionsTraits<NonMaxSuppressionV4Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV4Options;
};

template<> struct BuiltinOptionsTraits<NonMaxSuppressionV5Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_NonMaxSuppressionV5Options;
};

template<> struct BuiltinOptionsTraits<ScatterNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ScatterNdOptions;
};

template<> struct BuiltinOptionsTraits<SelectV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectV2Options;
};

template<> struct BuiltinOptionsTraits<DensifyOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DensifyOptions;
};

template<> struct BuiltinOptionsTraits<SegmentSumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SegmentSumOptions;
};

template<> struct BuiltinOptionsTraits<BatchMatMulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchMatMulOptions;
};

template<> struct BuiltinOptionsTraits<CumsumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CumsumOptions;
};

template<> struct BuiltinOptionsTraits<CallOnceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOnceOptions;
};

template<> struct BuiltinOptionsTraits<BroadcastToOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BroadcastToOptions;
};

template<> struct BuiltinOptionsTraits<Rfft2dOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Rfft2dOptions;
};

template<> struct BuiltinOptionsTraits<Conv3DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv3DOptions;
};

template<> struct BuiltinOptionsTraits<HashtableOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableOptions;
};

template<> struct BuiltinOptionsTraits<HashtableFindOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableFindOptions;
};

template<> struct BuiltinOptionsTraits<HashtableImportOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableImportOptions;
};

template<> struct BuiltinOptionsTraits<HashtableSizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_HashtableSizeOptions;
};

template<> struct BuiltinOptionsTraits<ENN_FlattenOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_FlattenOptions;
};

template<> struct BuiltinOptionsTraits<ENN_CropOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_CropOptions;
};

template<> struct BuiltinOptionsTraits<ENN_PermuteOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_PermuteOptions;
};

template<> struct BuiltinOptionsTraits<ENN_PriorBoxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_PriorBoxOptions;
};

template<> struct BuiltinOptionsTraits<ENN_DetectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_DetectionOptions;
};

template<> struct BuiltinOptionsTraits<ENN_PowerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_PowerOptions;
};

template<> struct BuiltinOptionsTraits<ENN_ScaleOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_ScaleOptions;
};

template<> struct BuiltinOptionsTraits<ENN_TFliteDetectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_TFliteDetectionOptions;
};

template<> struct BuiltinOptionsTraits<ENN_MeanOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_MeanOptions;
};

template<> struct BuiltinOptionsTraits<ENN_TFliteSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_TFliteSliceOptions;
};

template<> struct BuiltinOptionsTraits<ENN_ReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_ReluOptions;
};

template<> struct BuiltinOptionsTraits<ENN_EluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_EluOptions;
};

template<> struct BuiltinOptionsTraits<ENN_ClipOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_ClipOptions;
};

template<> struct BuiltinOptionsTraits<ENN_CFUOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_CFUOptions;
};

template<> struct BuiltinOptionsTraits<ENN_InverseCFUOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_InverseCFUOptions;
};

template<> struct BuiltinOptionsTraits<ENN_NormalizationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_NormalizationOptions;
};

template<> struct BuiltinOptionsTraits<ENN_NPUOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_NPUOptions;
};

template<> struct BuiltinOptionsTraits<ENN_DSPOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_DSPOptions;
};

template<> struct BuiltinOptionsTraits<ENN_UNIFIED_DEVICEOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ENN_UNIFIED_DEVICEOptions;
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Padding {
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2] {
  static const Padding values[] = {
    Padding_SAME,
    Padding_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadding() {
  static const char * const names[] = {
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadding(Padding e) {
  if (e < Padding_SAME || e > Padding_VALID) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,
    ActivationFunctionType_RELU,
    ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6,
    ActivationFunctionType_TANH,
    ActivationFunctionType_SIGN_BIT
  };
  return values;
}

inline const char * const *EnumNamesActivationFunctionType() {
  static const char * const names[] = {
    "NONE",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "TANH",
    "SIGN_BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
  if (e < ActivationFunctionType_NONE || e > ActivationFunctionType_SIGN_BIT) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
  static const LSHProjectionType values[] = {
    LSHProjectionType_UNKNOWN,
    LSHProjectionType_SPARSE,
    LSHProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLSHProjectionType() {
  static const char * const names[] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
  if (e < LSHProjectionType_UNKNOWN || e > LSHProjectionType_DENSE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
  };
  return values;
}

inline const char * const *EnumNamesFullyConnectedOptionsWeightsFormat() {
  static const char * const names[] = {
    "DEFAULT",
    "SHUFFLED4x16INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
  if (e < FullyConnectedOptionsWeightsFormat_DEFAULT || e > FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum NormRegion {
  NormRegion_ACROSS_CHANNELS = 0,
  NormRegion_WITHIN_CHANNEL = 1,
  NormRegion_MIN = NormRegion_ACROSS_CHANNELS,
  NormRegion_MAX = NormRegion_WITHIN_CHANNEL
};

inline const NormRegion (&EnumValuesNormRegion())[2] {
  static const NormRegion values[] = {
    NormRegion_ACROSS_CHANNELS,
    NormRegion_WITHIN_CHANNEL
  };
  return values;
}

inline const char * const *EnumNamesNormRegion() {
  static const char * const names[] = {
    "ACROSS_CHANNELS",
    "WITHIN_CHANNEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameNormRegion(NormRegion e) {
  if (e < NormRegion_ACROSS_CHANNELS || e > NormRegion_WITHIN_CHANNEL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNormRegion()[index];
}

enum LSTMKernelType {
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
  static const LSTMKernelType values[] = {
    LSTMKernelType_FULL,
    LSTMKernelType_BASIC
  };
  return values;
}

inline const char * const *EnumNamesLSTMKernelType() {
  static const char * const names[] = {
    "FULL",
    "BASIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
  if (e < LSTMKernelType_FULL || e > LSTMKernelType_BASIC) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
  static const CombinerType values[] = {
    CombinerType_SUM,
    CombinerType_MEAN,
    CombinerType_SQRTN
  };
  return values;
}

inline const char * const *EnumNamesCombinerType() {
  static const char * const names[] = {
    "SUM",
    "MEAN",
    "SQRTN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
  if (e < CombinerType_SUM || e > CombinerType_SQRTN) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCombinerType()[index];
}

enum QuantType {
  QuantType_SYMM = 0,
  QuantType_ASYMM = 1,
  QuantType_MIN = QuantType_SYMM,
  QuantType_MAX = QuantType_ASYMM
};

inline const QuantType (&EnumValuesQuantType())[2] {
  static const QuantType values[] = {
    QuantType_SYMM,
    QuantType_ASYMM
  };
  return values;
}

inline const char * const *EnumNamesQuantType() {
  static const char * const names[] = {
    "SYMM",
    "ASYMM",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantType(QuantType e) {
  if (e < QuantType_SYMM || e > QuantType_ASYMM) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantType()[index];
}

enum MirrorPadMode {
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
  static const MirrorPadMode values[] = {
    MirrorPadMode_REFLECT,
    MirrorPadMode_SYMMETRIC
  };
  return values;
}

inline const char * const *EnumNamesMirrorPadMode() {
  static const char * const names[] = {
    "REFLECT",
    "SYMMETRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {
  if (e < MirrorPadMode_REFLECT || e > MirrorPadMode_SYMMETRIC) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum PriorBoxCodingType {
  PriorBoxCodingType_CORNER = 0,
  PriorBoxCodingType_CENTER_SIZE = 1,
  PriorBoxCodingType_CORNER_SIZE = 2,
  PriorBoxCodingType_MIN = PriorBoxCodingType_CORNER,
  PriorBoxCodingType_MAX = PriorBoxCodingType_CORNER_SIZE
};

inline const PriorBoxCodingType (&EnumValuesPriorBoxCodingType())[3] {
  static const PriorBoxCodingType values[] = {
    PriorBoxCodingType_CORNER,
    PriorBoxCodingType_CENTER_SIZE,
    PriorBoxCodingType_CORNER_SIZE
  };
  return values;
}

inline const char * const *EnumNamesPriorBoxCodingType() {
  static const char * const names[] = {
    "CORNER",
    "CENTER_SIZE",
    "CORNER_SIZE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePriorBoxCodingType(PriorBoxCodingType e) {
  if (e < PriorBoxCodingType_CORNER || e > PriorBoxCodingType_CORNER_SIZE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPriorBoxCodingType()[index];
}

enum TargetHw {
  TargetHw_NONE = 0,
  TargetHw_CPU = 1,
  TargetHw_GPU = 2,
  TargetHw_NPU = 4,
  TargetHw_DSP = 8,
  TargetHw_UNIFIED = 16,
  TargetHw_MIN = TargetHw_NONE,
  TargetHw_MAX = TargetHw_UNIFIED
};

inline const TargetHw (&EnumValuesTargetHw())[6] {
  static const TargetHw values[] = {
    TargetHw_NONE,
    TargetHw_CPU,
    TargetHw_GPU,
    TargetHw_NPU,
    TargetHw_DSP,
    TargetHw_UNIFIED
  };
  return values;
}

inline const char * const *EnumNamesTargetHw() {
  static const char * const names[] = {
    "NONE",
    "CPU",
    "GPU",
    "",
    "NPU",
    "",
    "",
    "",
    "DSP",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "UNIFIED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTargetHw(TargetHw e) {
  if (e < TargetHw_NONE || e > TargetHw_UNIFIED) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTargetHw()[index];
}

enum CustomOptionsFormat {
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
  static const CustomOptionsFormat values[] = {
    CustomOptionsFormat_FLEXBUFFERS
  };
  return values;
}

inline const char * const *EnumNamesCustomOptionsFormat() {
  static const char * const names[] = {
    "FLEXBUFFERS",
    nullptr
  };
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
  if (e < CustomOptionsFormat_FLEXBUFFERS || e > CustomOptionsFormat_FLEXBUFFERS) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

enum LegacyModel {
  LegacyModel_CAFFE = 0,
  LegacyModel_TENSORFLOW = 1,
  LegacyModel_CAFFE_NCHW = 2,
  LegacyModel_CAFFE_NHWC = 3,
  LegacyModel_TENSORFLOW_NCHW = 4,
  LegacyModel_TENSORFLOW_NHWC = 5,
  LegacyModel_ANDROID_NN = 6,
  LegacyModel_MIN = LegacyModel_CAFFE,
  LegacyModel_MAX = LegacyModel_ANDROID_NN
};

inline const LegacyModel (&EnumValuesLegacyModel())[7] {
  static const LegacyModel values[] = {
    LegacyModel_CAFFE,
    LegacyModel_TENSORFLOW,
    LegacyModel_CAFFE_NCHW,
    LegacyModel_CAFFE_NHWC,
    LegacyModel_TENSORFLOW_NCHW,
    LegacyModel_TENSORFLOW_NHWC,
    LegacyModel_ANDROID_NN
  };
  return values;
}

inline const char * const *EnumNamesLegacyModel() {
  static const char * const names[] = {
    "CAFFE",
    "TENSORFLOW",
    "CAFFE_NCHW",
    "CAFFE_NHWC",
    "TENSORFLOW_NCHW",
    "TENSORFLOW_NHWC",
    "ANDROID_NN",
    nullptr
  };
  return names;
}

inline const char *EnumNameLegacyModel(LegacyModel e) {
  if (e < LegacyModel_CAFFE || e > LegacyModel_ANDROID_NN) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLegacyModel()[index];
}

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
};

struct CustomQuantizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomQuantizationBuilder &operator=(const CustomQuantizationBuilder &);
  flatbuffers::Offset<CustomQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *custom = nullptr) {
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return tflite::v2::CreateCustomQuantization(
      _fbb,
      custom__);
}

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14,
    VT_QUANTIZED_DIMENSION = 16
  };
  const flatbuffers::Vector<float> *min() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
  }
  const flatbuffers::Vector<float> *max() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const flatbuffers::Vector<int64_t> *zero_point() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  QuantizationDetails details_type() const {
    return static_cast<QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void *details() const {
    return GetPointer<const void *>(VT_DETAILS);
  }
  template<typename T> const T *details_as() const;
  const CustomQuantization *details_as_CustomQuantization() const {
    return details_type() == QuantizationDetails_CustomQuantization ? static_cast<const CustomQuantization *>(details()) : nullptr;
  }
  int32_t quantized_dimension() const {
    return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION) &&
           verifier.EndTable();
  }
};

template<> inline const CustomQuantization *QuantizationParameters::details_as<CustomQuantization>() const {
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(QuantizationDetails details_type) {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details) {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension) {
    fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);
  }
  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizationParametersBuilder &operator=(const QuantizationParametersBuilder &);
  flatbuffers::Offset<QuantizationParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
    QuantizationDetails details_type = QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<int64_t> *zero_point = nullptr,
    QuantizationDetails details_type = QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  auto min__ = min ? _fbb.CreateVector<float>(*min) : 0;
  auto max__ = max ? _fbb.CreateVector<float>(*max) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto zero_point__ = zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0;
  return tflite::v2::CreateQuantizationParameters(
      _fbb,
      min__,
      max__,
      scale__,
      zero_point__,
      details_type,
      details,
      quantized_dimension);
}

struct SymmPerChannelQuantParamters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALES = 4,
    VT_CHANNEL_DIM = 6
  };
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  uint32_t channel_dim() const {
    return GetField<uint32_t>(VT_CHANNEL_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyField<uint32_t>(verifier, VT_CHANNEL_DIM) &&
           verifier.EndTable();
  }
};

struct SymmPerChannelQuantParamtersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(SymmPerChannelQuantParamters::VT_SCALES, scales);
  }
  void add_channel_dim(uint32_t channel_dim) {
    fbb_.AddElement<uint32_t>(SymmPerChannelQuantParamters::VT_CHANNEL_DIM, channel_dim, 0);
  }
  explicit SymmPerChannelQuantParamtersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SymmPerChannelQuantParamtersBuilder &operator=(const SymmPerChannelQuantParamtersBuilder &);
  flatbuffers::Offset<SymmPerChannelQuantParamters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SymmPerChannelQuantParamters>(end);
    return o;
  }
};

inline flatbuffers::Offset<SymmPerChannelQuantParamters> CreateSymmPerChannelQuantParamters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0,
    uint32_t channel_dim = 0) {
  SymmPerChannelQuantParamtersBuilder builder_(_fbb);
  builder_.add_channel_dim(channel_dim);
  builder_.add_scales(scales);
  return builder_.Finish();
}

inline flatbuffers::Offset<SymmPerChannelQuantParamters> CreateSymmPerChannelQuantParamtersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *scales = nullptr,
    uint32_t channel_dim = 0) {
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return tflite::v2::CreateSymmPerChannelQuantParamters(
      _fbb,
      scales__,
      channel_dim);
}

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<int32_t> *values() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct Int32VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> values) {
    fbb_.AddOffset(Int32Vector::VT_VALUES, values);
  }
  explicit Int32VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int32VectorBuilder &operator=(const Int32VectorBuilder &);
  flatbuffers::Offset<Int32Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32Vector> CreateInt32Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> values = 0) {
  Int32VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Int32Vector> CreateInt32VectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<int32_t>(*values) : 0;
  return tflite::v2::CreateInt32Vector(
      _fbb,
      values__);
}

struct Uint16Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint16_t> *values() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct Uint16VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values) {
    fbb_.AddOffset(Uint16Vector::VT_VALUES, values);
  }
  explicit Uint16VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint16VectorBuilder &operator=(const Uint16VectorBuilder &);
  flatbuffers::Offset<Uint16Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint16Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint16Vector> CreateUint16Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> values = 0) {
  Uint16VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint16Vector> CreateUint16VectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<uint16_t>(*values) : 0;
  return tflite::v2::CreateUint16Vector(
      _fbb,
      values__);
}

struct Uint8Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<uint8_t> *values() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct Uint8VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values) {
    fbb_.AddOffset(Uint8Vector::VT_VALUES, values);
  }
  explicit Uint8VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Uint8VectorBuilder &operator=(const Uint8VectorBuilder &);
  flatbuffers::Offset<Uint8Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uint8Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uint8Vector> CreateUint8Vector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values = 0) {
  Uint8VectorBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uint8Vector> CreateUint8VectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<uint8_t>(*values) : 0;
  return tflite::v2::CreateUint8Vector(
      _fbb,
      values__);
}

struct DimensionMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_DENSE_SIZE = 6,
    VT_ARRAY_SEGMENTS_TYPE = 8,
    VT_ARRAY_SEGMENTS = 10,
    VT_ARRAY_INDICES_TYPE = 12,
    VT_ARRAY_INDICES = 14
  };
  DimensionType format() const {
    return static_cast<DimensionType>(GetField<int8_t>(VT_FORMAT, 0));
  }
  int32_t dense_size() const {
    return GetField<int32_t>(VT_DENSE_SIZE, 0);
  }
  SparseIndexVector array_segments_type() const {
    return static_cast<SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_SEGMENTS_TYPE, 0));
  }
  const void *array_segments() const {
    return GetPointer<const void *>(VT_ARRAY_SEGMENTS);
  }
  template<typename T> const T *array_segments_as() const;
  const Int32Vector *array_segments_as_Int32Vector() const {
    return array_segments_type() == SparseIndexVector_Int32Vector ? static_cast<const Int32Vector *>(array_segments()) : nullptr;
  }
  const Uint16Vector *array_segments_as_Uint16Vector() const {
    return array_segments_type() == SparseIndexVector_Uint16Vector ? static_cast<const Uint16Vector *>(array_segments()) : nullptr;
  }
  const Uint8Vector *array_segments_as_Uint8Vector() const {
    return array_segments_type() == SparseIndexVector_Uint8Vector ? static_cast<const Uint8Vector *>(array_segments()) : nullptr;
  }
  SparseIndexVector array_indices_type() const {
    return static_cast<SparseIndexVector>(GetField<uint8_t>(VT_ARRAY_INDICES_TYPE, 0));
  }
  const void *array_indices() const {
    return GetPointer<const void *>(VT_ARRAY_INDICES);
  }
  template<typename T> const T *array_indices_as() const;
  const Int32Vector *array_indices_as_Int32Vector() const {
    return array_indices_type() == SparseIndexVector_Int32Vector ? static_cast<const Int32Vector *>(array_indices()) : nullptr;
  }
  const Uint16Vector *array_indices_as_Uint16Vector() const {
    return array_indices_type() == SparseIndexVector_Uint16Vector ? static_cast<const Uint16Vector *>(array_indices()) : nullptr;
  }
  const Uint8Vector *array_indices_as_Uint8Vector() const {
    return array_indices_type() == SparseIndexVector_Uint8Vector ? static_cast<const Uint8Vector *>(array_indices()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_DENSE_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_SEGMENTS_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_SEGMENTS) &&
           VerifySparseIndexVector(verifier, array_segments(), array_segments_type()) &&
           VerifyField<uint8_t>(verifier, VT_ARRAY_INDICES_TYPE) &&
           VerifyOffset(verifier, VT_ARRAY_INDICES) &&
           VerifySparseIndexVector(verifier, array_indices(), array_indices_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Int32Vector *DimensionMetadata::array_segments_as<Int32Vector>() const {
  return array_segments_as_Int32Vector();
}

template<> inline const Uint16Vector *DimensionMetadata::array_segments_as<Uint16Vector>() const {
  return array_segments_as_Uint16Vector();
}

template<> inline const Uint8Vector *DimensionMetadata::array_segments_as<Uint8Vector>() const {
  return array_segments_as_Uint8Vector();
}

template<> inline const Int32Vector *DimensionMetadata::array_indices_as<Int32Vector>() const {
  return array_indices_as_Int32Vector();
}

template<> inline const Uint16Vector *DimensionMetadata::array_indices_as<Uint16Vector>() const {
  return array_indices_as_Uint16Vector();
}

template<> inline const Uint8Vector *DimensionMetadata::array_indices_as<Uint8Vector>() const {
  return array_indices_as_Uint8Vector();
}

struct DimensionMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(DimensionType format) {
    fbb_.AddElement<int8_t>(DimensionMetadata::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  void add_dense_size(int32_t dense_size) {
    fbb_.AddElement<int32_t>(DimensionMetadata::VT_DENSE_SIZE, dense_size, 0);
  }
  void add_array_segments_type(SparseIndexVector array_segments_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_SEGMENTS_TYPE, static_cast<uint8_t>(array_segments_type), 0);
  }
  void add_array_segments(flatbuffers::Offset<void> array_segments) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_SEGMENTS, array_segments);
  }
  void add_array_indices_type(SparseIndexVector array_indices_type) {
    fbb_.AddElement<uint8_t>(DimensionMetadata::VT_ARRAY_INDICES_TYPE, static_cast<uint8_t>(array_indices_type), 0);
  }
  void add_array_indices(flatbuffers::Offset<void> array_indices) {
    fbb_.AddOffset(DimensionMetadata::VT_ARRAY_INDICES, array_indices);
  }
  explicit DimensionMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DimensionMetadataBuilder &operator=(const DimensionMetadataBuilder &);
  flatbuffers::Offset<DimensionMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DimensionMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<DimensionMetadata> CreateDimensionMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    DimensionType format = DimensionType_DENSE,
    int32_t dense_size = 0,
    SparseIndexVector array_segments_type = SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_segments = 0,
    SparseIndexVector array_indices_type = SparseIndexVector_NONE,
    flatbuffers::Offset<void> array_indices = 0) {
  DimensionMetadataBuilder builder_(_fbb);
  builder_.add_array_indices(array_indices);
  builder_.add_array_segments(array_segments);
  builder_.add_dense_size(dense_size);
  builder_.add_array_indices_type(array_indices_type);
  builder_.add_array_segments_type(array_segments_type);
  builder_.add_format(format);
  return builder_.Finish();
}

struct SparsityParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAVERSAL_ORDER = 4,
    VT_BLOCK_MAP = 6,
    VT_DIM_METADATA = 8
  };
  const flatbuffers::Vector<int32_t> *traversal_order() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TRAVERSAL_ORDER);
  }
  const flatbuffers::Vector<int32_t> *block_map() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCK_MAP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>> *dim_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>> *>(VT_DIM_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAVERSAL_ORDER) &&
           verifier.VerifyVector(traversal_order()) &&
           VerifyOffset(verifier, VT_BLOCK_MAP) &&
           verifier.VerifyVector(block_map()) &&
           VerifyOffset(verifier, VT_DIM_METADATA) &&
           verifier.VerifyVector(dim_metadata()) &&
           verifier.VerifyVectorOfTables(dim_metadata()) &&
           verifier.EndTable();
  }
};

struct SparsityParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_traversal_order(flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order) {
    fbb_.AddOffset(SparsityParameters::VT_TRAVERSAL_ORDER, traversal_order);
  }
  void add_block_map(flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map) {
    fbb_.AddOffset(SparsityParameters::VT_BLOCK_MAP, block_map);
  }
  void add_dim_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>>> dim_metadata) {
    fbb_.AddOffset(SparsityParameters::VT_DIM_METADATA, dim_metadata);
  }
  explicit SparsityParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparsityParametersBuilder &operator=(const SparsityParametersBuilder &);
  flatbuffers::Offset<SparsityParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparsityParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> traversal_order = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> block_map = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DimensionMetadata>>> dim_metadata = 0) {
  SparsityParametersBuilder builder_(_fbb);
  builder_.add_dim_metadata(dim_metadata);
  builder_.add_block_map(block_map);
  builder_.add_traversal_order(traversal_order);
  return builder_.Finish();
}

inline flatbuffers::Offset<SparsityParameters> CreateSparsityParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *traversal_order = nullptr,
    const std::vector<int32_t> *block_map = nullptr,
    const std::vector<flatbuffers::Offset<DimensionMetadata>> *dim_metadata = nullptr) {
  auto traversal_order__ = traversal_order ? _fbb.CreateVector<int32_t>(*traversal_order) : 0;
  auto block_map__ = block_map ? _fbb.CreateVector<int32_t>(*block_map) : 0;
  auto dim_metadata__ = dim_metadata ? _fbb.CreateVector<flatbuffers::Offset<DimensionMetadata>>(*dim_metadata) : 0;
  return tflite::v2::CreateSparsityParameters(
      _fbb,
      traversal_order__,
      block_map__,
      dim_metadata__);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14,
    VT_SPARSITY = 16,
    VT_SHAPE_SIGNATURE = 18,
    VT_PRE_OPERATOR = 20,
    VT_NEXT_OPERATORS = 22,
    VT_EXTRAM_PARAM = 24
  };
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  TensorType type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const QuantizationParameters *quantization() const {
    return GetPointer<const QuantizationParameters *>(VT_QUANTIZATION);
  }
  bool is_variable() const {
    return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0;
  }
  const SparsityParameters *sparsity() const {
    return GetPointer<const SparsityParameters *>(VT_SPARSITY);
  }
  const flatbuffers::Vector<int32_t> *shape_signature() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE_SIGNATURE);
  }
  int32_t pre_operator() const {
    return GetField<int32_t>(VT_PRE_OPERATOR, -1);
  }
  const flatbuffers::Vector<int32_t> *next_operators() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEXT_OPERATORS);
  }
  const SymmPerChannelQuantParamters *extram_param() const {
    return GetPointer<const SymmPerChannelQuantParamters *>(VT_EXTRAM_PARAM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) &&
           VerifyOffset(verifier, VT_SPARSITY) &&
           verifier.VerifyTable(sparsity()) &&
           VerifyOffset(verifier, VT_SHAPE_SIGNATURE) &&
           verifier.VerifyVector(shape_signature()) &&
           VerifyField<int32_t>(verifier, VT_PRE_OPERATOR) &&
           VerifyOffset(verifier, VT_NEXT_OPERATORS) &&
           verifier.VerifyVector(next_operators()) &&
           VerifyOffset(verifier, VT_EXTRAM_PARAM) &&
           verifier.VerifyTable(extram_param()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(TensorType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(flatbuffers::Offset<QuantizationParameters> quantization) {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable) {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
  }
  void add_sparsity(flatbuffers::Offset<SparsityParameters> sparsity) {
    fbb_.AddOffset(Tensor::VT_SPARSITY, sparsity);
  }
  void add_shape_signature(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature) {
    fbb_.AddOffset(Tensor::VT_SHAPE_SIGNATURE, shape_signature);
  }
  void add_pre_operator(int32_t pre_operator) {
    fbb_.AddElement<int32_t>(Tensor::VT_PRE_OPERATOR, pre_operator, -1);
  }
  void add_next_operators(flatbuffers::Offset<flatbuffers::Vector<int32_t>> next_operators) {
    fbb_.AddOffset(Tensor::VT_NEXT_OPERATORS, next_operators);
  }
  void add_extram_param(flatbuffers::Offset<SymmPerChannelQuantParamters> extram_param) {
    fbb_.AddOffset(Tensor::VT_EXTRAM_PARAM, extram_param);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    TensorType type = TensorType_FLOAT32,
    uint32_t buffer = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<QuantizationParameters> quantization = 0,
    bool is_variable = false,
    flatbuffers::Offset<SparsityParameters> sparsity = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape_signature = 0,
    int32_t pre_operator = -1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> next_operators = 0,
    flatbuffers::Offset<SymmPerChannelQuantParamters> extram_param = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_extram_param(extram_param);
  builder_.add_next_operators(next_operators);
  builder_.add_pre_operator(pre_operator);
  builder_.add_shape_signature(shape_signature);
  builder_.add_sparsity(sparsity);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    TensorType type = TensorType_FLOAT32,
    uint32_t buffer = 0,
    const char *name = nullptr,
    flatbuffers::Offset<QuantizationParameters> quantization = 0,
    bool is_variable = false,
    flatbuffers::Offset<SparsityParameters> sparsity = 0,
    const std::vector<int32_t> *shape_signature = nullptr,
    int32_t pre_operator = -1,
    const std::vector<int32_t> *next_operators = nullptr,
    flatbuffers::Offset<SymmPerChannelQuantParamters> extram_param = 0) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape_signature__ = shape_signature ? _fbb.CreateVector<int32_t>(*shape_signature) : 0;
  auto next_operators__ = next_operators ? _fbb.CreateVector<int32_t>(*next_operators) : 0;
  return tflite::v2::CreateTensor(
      _fbb,
      shape__,
      type,
      buffer,
      name__,
      quantization,
      is_variable,
      sparsity,
      shape_signature__,
      pre_operator,
      next_operators__,
      extram_param);
}

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14,
    VT_PADDING_VALUE = 16,
    VT_USE_NCHW = 18
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  const flatbuffers::Vector<int32_t> *padding_value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDING_VALUE);
  }
  bool use_nchw() const {
    return GetField<uint8_t>(VT_USE_NCHW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           VerifyOffset(verifier, VT_PADDING_VALUE) &&
           verifier.VerifyVector(padding_value()) &&
           VerifyField<uint8_t>(verifier, VT_USE_NCHW) &&
           verifier.EndTable();
  }
};

struct Conv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  void add_padding_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value) {
    fbb_.AddOffset(Conv2DOptions::VT_PADDING_VALUE, padding_value);
  }
  void add_use_nchw(bool use_nchw) {
    fbb_.AddElement<uint8_t>(Conv2DOptions::VT_USE_NCHW, static_cast<uint8_t>(use_nchw), 0);
  }
  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DOptionsBuilder &operator=(const Conv2DOptionsBuilder &);
  flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value = 0,
    bool use_nchw = false) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_padding_value(padding_value);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_use_nchw(use_nchw);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1,
    const std::vector<int32_t> *padding_value = nullptr,
    bool use_nchw = false) {
  auto padding_value__ = padding_value ? _fbb.CreateVector<int32_t>(*padding_value) : 0;
  return tflite::v2::CreateConv2DOptions(
      _fbb,
      padding,
      stride_w,
      stride_h,
      fused_activation_function,
      dilation_w_factor,
      dilation_h_factor,
      padding_value__,
      use_nchw);
}

struct Conv3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_D = 6,
    VT_STRIDE_W = 8,
    VT_STRIDE_H = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_D_FACTOR = 14,
    VT_DILATION_W_FACTOR = 16,
    VT_DILATION_H_FACTOR = 18
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_d() const {
    return GetField<int32_t>(VT_STRIDE_D, 0);
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_d_factor() const {
    return GetField<int32_t>(VT_DILATION_D_FACTOR, 1);
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_D) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_D_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
};

struct Conv3DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_d(int32_t stride_d) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_D, stride_d, 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv3DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_d_factor(int32_t dilation_d_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_D_FACTOR, dilation_d_factor, 1);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv3DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv3DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv3DOptionsBuilder &operator=(const Conv3DOptionsBuilder &);
  flatbuffers::Offset<Conv3DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv3DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv3DOptions> CreateConv3DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_d = 0,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_d_factor = 1,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv3DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_dilation_d_factor(dilation_d_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_stride_d(stride_d);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14,
    VT_PADDING_VALUE = 16,
    VT_USE_NCHW = 18
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t filter_width() const {
    return GetField<int32_t>(VT_FILTER_WIDTH, 0);
  }
  int32_t filter_height() const {
    return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  const flatbuffers::Vector<int32_t> *padding_value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDING_VALUE);
  }
  bool use_nchw() const {
    return GetField<uint8_t>(VT_USE_NCHW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyOffset(verifier, VT_PADDING_VALUE) &&
           verifier.VerifyVector(padding_value()) &&
           VerifyField<uint8_t>(verifier, VT_USE_NCHW) &&
           verifier.EndTable();
  }
};

struct Pool2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_padding_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value) {
    fbb_.AddOffset(Pool2DOptions::VT_PADDING_VALUE, padding_value);
  }
  void add_use_nchw(bool use_nchw) {
    fbb_.AddElement<uint8_t>(Pool2DOptions::VT_USE_NCHW, static_cast<uint8_t>(use_nchw), 0);
  }
  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool2DOptionsBuilder &operator=(const Pool2DOptionsBuilder &);
  flatbuffers::Offset<Pool2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t filter_width = 0,
    int32_t filter_height = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value = 0,
    bool use_nchw = false) {
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_padding_value(padding_value);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_use_nchw(use_nchw);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t filter_width = 0,
    int32_t filter_height = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    const std::vector<int32_t> *padding_value = nullptr,
    bool use_nchw = false) {
  auto padding_value__ = padding_value ? _fbb.CreateVector<int32_t>(*padding_value) : 0;
  return tflite::v2::CreatePool2DOptions(
      _fbb,
      padding,
      stride_w,
      stride_h,
      filter_width,
      filter_height,
      fused_activation_function,
      padding_value__,
      use_nchw);
}

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16,
    VT_PADDING_VALUE = 18,
    VT_USE_NCHW = 20
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  const flatbuffers::Vector<int32_t> *padding_value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDING_VALUE);
  }
  bool use_nchw() const {
    return GetField<uint8_t>(VT_USE_NCHW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           VerifyOffset(verifier, VT_PADDING_VALUE) &&
           verifier.VerifyVector(padding_value()) &&
           VerifyField<uint8_t>(verifier, VT_USE_NCHW) &&
           verifier.EndTable();
  }
};

struct DepthwiseConv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  void add_padding_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value) {
    fbb_.AddOffset(DepthwiseConv2DOptions::VT_PADDING_VALUE, padding_value);
  }
  void add_use_nchw(bool use_nchw) {
    fbb_.AddElement<uint8_t>(DepthwiseConv2DOptions::VT_USE_NCHW, static_cast<uint8_t>(use_nchw), 0);
  }
  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DOptionsBuilder &operator=(const DepthwiseConv2DOptionsBuilder &);
  flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t depth_multiplier = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value = 0,
    bool use_nchw = false) {
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_padding_value(padding_value);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_use_nchw(use_nchw);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t depth_multiplier = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1,
    const std::vector<int32_t> *padding_value = nullptr,
    bool use_nchw = false) {
  auto padding_value__ = padding_value ? _fbb.CreateVector<int32_t>(*padding_value) : 0;
  return tflite::v2::CreateDepthwiseConv2DOptions(
      _fbb,
      padding,
      stride_w,
      stride_h,
      depth_multiplier,
      fused_activation_function,
      dilation_w_factor,
      dilation_h_factor,
      padding_value__,
      use_nchw);
}

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const {
    return GetField<int32_t>(VT_NUM_CHANNELS, 0);
  }
  const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) &&
           verifier.EndTable();
  }
};

struct ConcatEmbeddingsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels) {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatEmbeddingsOptionsBuilder &operator=(const ConcatEmbeddingsOptionsBuilder &);
  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    const std::vector<int32_t> *num_columns_per_channel = nullptr,
    const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {
  auto num_columns_per_channel__ = num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0;
  auto embedding_dim_per_channel__ = embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0;
  return tflite::v2::CreateConcatEmbeddingsOptions(
      _fbb,
      num_channels,
      num_columns_per_channel__,
      embedding_dim_per_channel__);
}

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  LSHProjectionType type() const {
    return static_cast<LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LSHProjectionOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(LSHProjectionType type) {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSHProjectionOptionsBuilder &operator=(const LSHProjectionOptionsBuilder &);
  flatbuffers::Offset<LSHProjectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    LSHProjectionType type = LSHProjectionType_UNKNOWN) {
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct SVDFOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SVDFOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVDFOptionsBuilder &operator=(const SVDFOptionsBuilder &);
  flatbuffers::Offset<SVDFOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 6
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct RNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(RNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNOptionsBuilder &operator=(const RNNOptionsBuilder &);
  flatbuffers::Offset<RNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct SequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceRNNOptionsBuilder &operator=(const SequenceRNNOptionsBuilder &);
  flatbuffers::Offset<SequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool asymmetric_quantize_inputs = false) {
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct BidirectionalSequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceRNNOptionsBuilder &operator=(const BidirectionalSequenceRNNOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool merge_outputs = false,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6,
    VT_KEEP_NUM_DIMS = 8,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 10
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  FullyConnectedOptionsWeightsFormat weights_format() const {
    return static_cast<FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool keep_num_dims() const {
    return GetField<uint8_t>(VT_KEEP_NUM_DIMS, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_NUM_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct FullyConnectedOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(FullyConnectedOptionsWeightsFormat weights_format) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, static_cast<int8_t>(weights_format), 0);
  }
  void add_keep_num_dims(bool keep_num_dims) {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, static_cast<uint8_t>(keep_num_dims), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(FullyConnectedOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullyConnectedOptionsBuilder &operator=(const FullyConnectedOptionsBuilder &);
  flatbuffers::Offset<FullyConnectedOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    FullyConnectedOptionsWeightsFormat weights_format = FullyConnectedOptionsWeightsFormat_DEFAULT,
    bool keep_num_dims = false,
    bool asymmetric_quantize_inputs = false) {
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_keep_num_dims(keep_num_dims);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4,
    VT_AXIS = 6
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct SoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SoftmaxOptions::VT_AXIS, axis, 0);
  }
  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxOptionsBuilder &operator=(const SoftmaxOptionsBuilder &);
  flatbuffers::Offset<SoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f,
    int32_t axis = 0) {
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct ConcatenationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatenationOptionsBuilder &operator=(const ConcatenationOptionsBuilder &);
  flatbuffers::Offset<ConcatenationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6,
    VT_COEFF = 8
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
};

struct AddOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(AddOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(AddOptions::VT_COEFF, coeff);
  }
  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddOptionsBuilder &operator=(const AddOptionsBuilder &);
  flatbuffers::Offset<AddOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool pot_scale_int16 = true,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  AddOptionsBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

inline flatbuffers::Offset<AddOptions> CreateAddOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool pot_scale_int16 = true,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return tflite::v2::CreateAddOptions(
      _fbb,
      fused_activation_function,
      pot_scale_int16,
      coeff__);
}

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_COEFF = 6
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
};

struct MulOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(MulOptions::VT_COEFF, coeff);
  }
  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulOptionsBuilder &operator=(const MulOptionsBuilder &);
  flatbuffers::Offset<MulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  MulOptionsBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

inline flatbuffers::Offset<MulOptions> CreateMulOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return tflite::v2::CreateMulOptions(
      _fbb,
      fused_activation_function,
      coeff__);
}

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct L2NormOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormOptionsBuilder &operator=(const L2NormOptionsBuilder &);
  flatbuffers::Offset<L2NormOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10,
    VT_NORM_REGION = 12
  };
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  NormRegion norm_region() const {
    return static_cast<NormRegion>(GetField<int8_t>(VT_NORM_REGION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyField<int8_t>(verifier, VT_NORM_REGION) &&
           verifier.EndTable();
  }
};

struct LocalResponseNormalizationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
  }
  void add_norm_region(NormRegion norm_region) {
    fbb_.AddElement<int8_t>(LocalResponseNormalizationOptions::VT_NORM_REGION, static_cast<int8_t>(norm_region), 0);
  }
  explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationOptionsBuilder &operator=(const LocalResponseNormalizationOptionsBuilder &);
  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f,
    NormRegion norm_region = NormRegion_ACROSS_CHANNELS) {
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  builder_.add_norm_region(norm_region);
  return builder_.Finish();
}

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  LSTMKernelType kernel_type() const {
    return static_cast<LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct LSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(LSTMKernelType kernel_type) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(LSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMOptionsBuilder &operator=(const LSTMOptionsBuilder &);
  flatbuffers::Offset<LSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    LSTMKernelType kernel_type = LSTMKernelType_FULL,
    bool asymmetric_quantize_inputs = false) {
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 12
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnidirectionalSequenceLSTMOptionsBuilder &operator=(const UnidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool time_major = false,
    bool asymmetric_quantize_inputs = false) {
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10,
    VT_TIME_MAJOR = 12,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 14
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct BidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 1);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceLSTMOptionsBuilder &operator=(const BidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool merge_outputs = false,
    bool time_major = true,
    bool asymmetric_quantize_inputs = false) {
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 8,
    VT_HALF_PIXEL_CENTERS = 10,
    VT_USE_NCHW = 12
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool use_nchw() const {
    return GetField<uint8_t>(VT_USE_NCHW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) &&
           VerifyField<uint8_t>(verifier, VT_USE_NCHW) &&
           verifier.EndTable();
  }
};

struct ResizeBilinearOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  void add_use_nchw(bool use_nchw) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_USE_NCHW, static_cast<uint8_t>(use_nchw), 0);
  }
  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBilinearOptionsBuilder &operator=(const ResizeBilinearOptionsBuilder &);
  flatbuffers::Offset<ResizeBilinearOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false,
    bool use_nchw = false) {
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_use_nchw(use_nchw);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIGN_CORNERS = 4,
    VT_HALF_PIXEL_CENTERS = 6
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool half_pixel_centers() const {
    return GetField<uint8_t>(VT_HALF_PIXEL_CENTERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           VerifyField<uint8_t>(verifier, VT_HALF_PIXEL_CENTERS) &&
           verifier.EndTable();
  }
};

struct ResizeNearestNeighborOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  void add_half_pixel_centers(bool half_pixel_centers) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_HALF_PIXEL_CENTERS, static_cast<uint8_t>(half_pixel_centers), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeNearestNeighborOptionsBuilder &operator=(const ResizeNearestNeighborOptionsBuilder &);
  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false,
    bool half_pixel_centers = false) {
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_half_pixel_centers(half_pixel_centers);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const {
    return GetField<uint32_t>(VT_SUBGRAPH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH) &&
           verifier.EndTable();
  }
};

struct CallOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph) {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOptionsBuilder &operator=(const CallOptionsBuilder &);
  flatbuffers::Offset<CallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t subgraph = 0) {
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadOptionsBuilder &operator=(const PadOptionsBuilder &);
  flatbuffers::Offset<PadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PadV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadV2OptionsBuilder &operator=(const PadV2OptionsBuilder &);
  flatbuffers::Offset<PadV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *new_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) &&
           verifier.EndTable();
  }
};

struct ReshapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeOptionsBuilder &operator=(const ReshapeOptionsBuilder &);
  flatbuffers::Offset<ReshapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *new_shape = nullptr) {
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return tflite::v2::CreateReshapeOptions(
      _fbb,
      new_shape__);
}

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDOptionsBuilder &operator=(const SpaceToBatchNDOptionsBuilder &);
  flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceNDOptionsBuilder &operator=(const BatchToSpaceNDOptionsBuilder &);
  flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const {
    return GetField<int32_t>(VT_NGRAM_SIZE, 0);
  }
  int32_t max_skip_size() const {
    return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
  }
  bool include_all_ngrams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) &&
           verifier.EndTable();
  }
};

struct SkipGramOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams) {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkipGramOptionsBuilder &operator=(const SkipGramOptionsBuilder &);
  flatbuffers::Offset<SkipGramOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ngram_size = 0,
    int32_t max_skip_size = 0,
    bool include_all_ngrams = false) {
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           verifier.EndTable();
  }
};

struct SpaceToDepthOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthOptionsBuilder &operator=(const SpaceToDepthOptionsBuilder &);
  flatbuffers::Offset<SpaceToDepthOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

struct DepthToSpaceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_USE_NCHW = 6
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool use_nchw() const {
    return GetField<uint8_t>(VT_USE_NCHW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_USE_NCHW) &&
           verifier.EndTable();
  }
};

struct DepthToSpaceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  void add_use_nchw(bool use_nchw) {
    fbb_.AddElement<uint8_t>(DepthToSpaceOptions::VT_USE_NCHW, static_cast<uint8_t>(use_nchw), 0);
  }
  explicit DepthToSpaceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthToSpaceOptionsBuilder &operator=(const DepthToSpaceOptionsBuilder &);
  flatbuffers::Offset<DepthToSpaceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpaceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpaceOptions> CreateDepthToSpaceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0,
    bool use_nchw = false) {
  DepthToSpaceOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  builder_.add_use_nchw(use_nchw);
  return builder_.Finish();
}

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_POT_SCALE_INT16 = 6,
    VT_COEFF = 8
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool pot_scale_int16() const {
    return GetField<uint8_t>(VT_POT_SCALE_INT16, 1) != 0;
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_POT_SCALE_INT16) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
};

struct SubOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_pot_scale_int16(bool pot_scale_int16) {
    fbb_.AddElement<uint8_t>(SubOptions::VT_POT_SCALE_INT16, static_cast<uint8_t>(pot_scale_int16), 1);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(SubOptions::VT_COEFF, coeff);
  }
  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubOptionsBuilder &operator=(const SubOptionsBuilder &);
  flatbuffers::Offset<SubOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool pot_scale_int16 = true,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  SubOptionsBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_pot_scale_int16(pot_scale_int16);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubOptions> CreateSubOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool pot_scale_int16 = true,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return tflite::v2::CreateSubOptions(
      _fbb,
      fused_activation_function,
      pot_scale_int16,
      coeff__);
}

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_COEFF = 6
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
};

struct DivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(DivOptions::VT_COEFF, coeff);
  }
  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivOptionsBuilder &operator=(const DivOptionsBuilder &);
  flatbuffers::Offset<DivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  DivOptionsBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

inline flatbuffers::Offset<DivOptions> CreateDivOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return tflite::v2::CreateDivOptions(
      _fbb,
      fused_activation_function,
      coeff__);
}

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TopKV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2OptionsBuilder &operator=(const TopKV2OptionsBuilder &);
  flatbuffers::Offset<TopKV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMBINER = 4
  };
  CombinerType combiner() const {
    return static_cast<CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMBINER) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupSparseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_combiner(CombinerType combiner) {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseOptionsBuilder &operator=(const EmbeddingLookupSparseOptionsBuilder &);
  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    CombinerType combiner = CombinerType_SUM) {
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_BATCH_DIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t batch_dims() const {
    return GetField<int32_t>(VT_BATCH_DIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIMS) &&
           verifier.EndTable();
  }
};

struct GatherOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
  }
  void add_batch_dims(int32_t batch_dims) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_BATCH_DIMS, batch_dims, 0);
  }
  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherOptionsBuilder &operator=(const GatherOptionsBuilder &);
  flatbuffers::Offset<GatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t batch_dims = 0) {
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_batch_dims(batch_dims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TransposeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeOptionsBuilder &operator=(const TransposeOptionsBuilder &);
  flatbuffers::Offset<TransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExpOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpOptionsBuilder &operator=(const ExpOptionsBuilder &);
  flatbuffers::Offset<ExpOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CosOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CosOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosOptionsBuilder &operator=(const CosOptionsBuilder &);
  flatbuffers::Offset<CosOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CosOptions> CreateCosOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
};

struct ReducerOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReducerOptionsBuilder &operator=(const ReducerOptionsBuilder &);
  flatbuffers::Offset<ReducerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false) {
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUEEZE_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *squeeze_dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) &&
           verifier.EndTable();
  }
};

struct SqueezeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeOptionsBuilder &operator=(const SqueezeOptionsBuilder &);
  flatbuffers::Offset<SqueezeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeeze_dims = nullptr) {
  auto squeeze_dims__ = squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0;
  return tflite::v2::CreateSqueezeOptions(
      _fbb,
      squeeze_dims__);
}

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4,
    VT_AXIS = 6
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct SplitOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SplitOptions::VT_AXIS, axis, 0);
  }
  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitOptionsBuilder &operator=(const SplitOptionsBuilder &);
  flatbuffers::Offset<SplitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0,
    int32_t axis = 0) {
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
};

struct SplitVOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitVOptionsBuilder &operator=(const SplitVOptionsBuilder &);
  flatbuffers::Offset<SplitVOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t ellipsis_mask() const {
    return GetField<int32_t>(VT_ELLIPSIS_MASK, 0);
  }
  int32_t new_axis_mask() const {
    return GetField<int32_t>(VT_NEW_AXIS_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int32_t>(verifier, VT_END_MASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
};

struct StridedSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceOptionsBuilder &operator=(const StridedSliceOptionsBuilder &);
  flatbuffers::Offset<StridedSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t ellipsis_mask = 0,
    int32_t new_axis_mask = 0,
    int32_t shrink_axis_mask = 0) {
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogSoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogSoftmaxOptionsBuilder &operator=(const LogSoftmaxOptionsBuilder &);
  flatbuffers::Offset<LogSoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  TensorType in_data_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  TensorType out_data_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) &&
           verifier.EndTable();
  }
};

struct CastOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_data_type(TensorType in_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(TensorType out_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastOptionsBuilder &operator=(const CastOptionsBuilder &);
  flatbuffers::Offset<CastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType in_data_type = TensorType_FLOAT32,
    TensorType out_data_type = TensorType_FLOAT32) {
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_FRACTIONAL_LENGTH = 6,
    VT_SCALE_OUT = 8,
    VT_ZERO_POINT_OUTPUT = 10
  };
  QuantType type() const {
    return static_cast<QuantType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<int32_t> *fractional_length() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FRACTIONAL_LENGTH);
  }
  const flatbuffers::Vector<float> *scale_out() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE_OUT);
  }
  const flatbuffers::Vector<int32_t> *zero_point_output() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ZERO_POINT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FRACTIONAL_LENGTH) &&
           verifier.VerifyVector(fractional_length()) &&
           VerifyOffset(verifier, VT_SCALE_OUT) &&
           verifier.VerifyVector(scale_out()) &&
           VerifyOffset(verifier, VT_ZERO_POINT_OUTPUT) &&
           verifier.VerifyVector(zero_point_output()) &&
           verifier.EndTable();
  }
};

struct DequantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(QuantType type) {
    fbb_.AddElement<int8_t>(DequantizeOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_fractional_length(flatbuffers::Offset<flatbuffers::Vector<int32_t>> fractional_length) {
    fbb_.AddOffset(DequantizeOptions::VT_FRACTIONAL_LENGTH, fractional_length);
  }
  void add_scale_out(flatbuffers::Offset<flatbuffers::Vector<float>> scale_out) {
    fbb_.AddOffset(DequantizeOptions::VT_SCALE_OUT, scale_out);
  }
  void add_zero_point_output(flatbuffers::Offset<flatbuffers::Vector<int32_t>> zero_point_output) {
    fbb_.AddOffset(DequantizeOptions::VT_ZERO_POINT_OUTPUT, zero_point_output);
  }
  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DequantizeOptionsBuilder &operator=(const DequantizeOptionsBuilder &);
  flatbuffers::Offset<DequantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    QuantType type = QuantType_SYMM,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> fractional_length = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale_out = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> zero_point_output = 0) {
  DequantizeOptionsBuilder builder_(_fbb);
  builder_.add_zero_point_output(zero_point_output);
  builder_.add_scale_out(scale_out);
  builder_.add_fractional_length(fractional_length);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    QuantType type = QuantType_SYMM,
    const std::vector<int32_t> *fractional_length = nullptr,
    const std::vector<float> *scale_out = nullptr,
    const std::vector<int32_t> *zero_point_output = nullptr) {
  auto fractional_length__ = fractional_length ? _fbb.CreateVector<int32_t>(*fractional_length) : 0;
  auto scale_out__ = scale_out ? _fbb.CreateVector<float>(*scale_out) : 0;
  auto zero_point_output__ = zero_point_output ? _fbb.CreateVector<int32_t>(*zero_point_output) : 0;
  return tflite::v2::CreateDequantizeOptions(
      _fbb,
      type,
      fractional_length__,
      scale_out__,
      zero_point_output__);
}

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COEFF = 4
  };
  const flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
};

struct MaximumMinimumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coeff(flatbuffers::Offset<flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(MaximumMinimumOptions::VT_COEFF, coeff);
  }
  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumMinimumOptionsBuilder &operator=(const MaximumMinimumOptionsBuilder &);
  flatbuffers::Offset<MaximumMinimumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> coeff = 0) {
  MaximumMinimumOptionsBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return tflite::v2::CreateMaximumMinimumOptions(
      _fbb,
      coeff__);
}

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileOptionsBuilder &operator=(const TileOptionsBuilder &);
  flatbuffers::Offset<TileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  TensorType output_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
};

struct ArgMaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxOptionsBuilder &operator=(const ArgMaxOptionsBuilder &);
  flatbuffers::Offset<ArgMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType output_type = TensorType_FLOAT32) {
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TYPE = 4
  };
  TensorType output_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
};

struct ArgMinOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinOptionsBuilder &operator=(const ArgMinOptionsBuilder &);
  flatbuffers::Offset<ArgMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType output_type = TensorType_FLOAT32) {
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterOptionsBuilder &operator=(const GreaterOptionsBuilder &);
  flatbuffers::Offset<GreaterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualOptionsBuilder &operator=(const GreaterEqualOptionsBuilder &);
  flatbuffers::Offset<GreaterEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessOptionsBuilder &operator=(const LessOptionsBuilder &);
  flatbuffers::Offset<LessOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualOptionsBuilder &operator=(const LessEqualOptionsBuilder &);
  flatbuffers::Offset<LessEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NegOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegOptionsBuilder &operator=(const NegOptionsBuilder &);
  flatbuffers::Offset<NegOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SelectOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectOptionsBuilder &operator=(const SelectOptionsBuilder &);
  flatbuffers::Offset<SelectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SLICE_POINT = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *slice_point() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SLICE_POINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_SLICE_POINT) &&
           verifier.VerifyVector(slice_point()) &&
           verifier.EndTable();
  }
};

struct SliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SliceOptions::VT_AXIS, axis, 0);
  }
  void add_slice_point(flatbuffers::Offset<flatbuffers::Vector<int32_t>> slice_point) {
    fbb_.AddOffset(SliceOptions::VT_SLICE_POINT, slice_point);
  }
  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceOptionsBuilder &operator=(const SliceOptionsBuilder &);
  flatbuffers::Offset<SliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> slice_point = 0) {
  SliceOptionsBuilder builder_(_fbb);
  builder_.add_slice_point(slice_point);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<SliceOptions> CreateSliceOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *slice_point = nullptr) {
  auto slice_point__ = slice_point ? _fbb.CreateVector<int32_t>(*slice_point) : 0;
  return tflite::v2::CreateSliceOptions(
      _fbb,
      axis,
      slice_point__);
}

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_GROUP = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_PADDING_VALUE = 14,
    VT_USE_NCHW = 16
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  const flatbuffers::Vector<int32_t> *padding_value() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDING_VALUE);
  }
  bool use_nchw() const {
    return GetField<uint8_t>(VT_USE_NCHW, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyOffset(verifier, VT_PADDING_VALUE) &&
           verifier.VerifyVector(padding_value()) &&
           VerifyField<uint8_t>(verifier, VT_USE_NCHW) &&
           verifier.EndTable();
  }
};

struct TransposeConvOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_GROUP, group, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_padding_value(flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value) {
    fbb_.AddOffset(TransposeConvOptions::VT_PADDING_VALUE, padding_value);
  }
  void add_use_nchw(bool use_nchw) {
    fbb_.AddElement<uint8_t>(TransposeConvOptions::VT_USE_NCHW, static_cast<uint8_t>(use_nchw), 0);
  }
  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeConvOptionsBuilder &operator=(const TransposeConvOptionsBuilder &);
  flatbuffers::Offset<TransposeConvOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t group = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> padding_value = 0,
    bool use_nchw = false) {
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_padding_value(padding_value);
  builder_.add_group(group);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_use_nchw(use_nchw);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t group = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    const std::vector<int32_t> *padding_value = nullptr,
    bool use_nchw = false) {
  auto padding_value__ = padding_value ? _fbb.CreateVector<int32_t>(*padding_value) : 0;
  return tflite::v2::CreateTransposeConvOptions(
      _fbb,
      padding,
      stride_w,
      stride_h,
      group,
      fused_activation_function,
      padding_value__,
      use_nchw);
}

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExpandDimsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsOptionsBuilder &operator=(const ExpandDimsOptionsBuilder &);
  flatbuffers::Offset<ExpandDimsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const {
    return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES) &&
           verifier.EndTable();
  }
};

struct SparseToDenseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices) {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES, static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseOptionsBuilder &operator=(const SparseToDenseOptionsBuilder &);
  flatbuffers::Offset<SparseToDenseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool validate_indices = false) {
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualOptionsBuilder &operator=(const EqualOptionsBuilder &);
  flatbuffers::Offset<EqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NotEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualOptionsBuilder &operator=(const NotEqualOptionsBuilder &);
  flatbuffers::Offset<NotEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUT_TYPE = 4
  };
  TensorType out_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUT_TYPE) &&
           verifier.EndTable();
  }
};

struct ShapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_type(TensorType out_type) {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeOptionsBuilder &operator=(const ShapeOptionsBuilder &);
  flatbuffers::Offset<ShapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType out_type = TensorType_FLOAT32) {
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

struct RankOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RankOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankOptionsBuilder &operator=(const RankOptionsBuilder &);
  flatbuffers::Offset<RankOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankOptions> CreateRankOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PowOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowOptionsBuilder &operator=(const PowOptionsBuilder &);
  flatbuffers::Offset<PowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  int32_t num_bits() const {
    return GetField<int32_t>(VT_NUM_BITS, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
};

struct FakeQuantOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
  }
  void add_num_bits(int32_t num_bits) {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantOptionsBuilder &operator=(const FakeQuantOptionsBuilder &);
  flatbuffers::Offset<FakeQuantOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int32_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const {
    return GetField<int32_t>(VT_VALUES_COUNT, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct PackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count) {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
  }
  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackOptionsBuilder &operator=(const PackOptionsBuilder &);
  flatbuffers::Offset<PackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t values_count = 0,
    int32_t axis = 0) {
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalOrOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrOptionsBuilder &operator=(const LogicalOrOptionsBuilder &);
  flatbuffers::Offset<LogicalOrOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct OneHotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
  }
  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotOptionsBuilder &operator=(const OneHotOptionsBuilder &);
  flatbuffers::Offset<OneHotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AbsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsOptionsBuilder &operator=(const AbsOptionsBuilder &);
  flatbuffers::Offset<AbsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HardSwishOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HardSwishOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HardSwishOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HardSwishOptionsBuilder &operator=(const HardSwishOptionsBuilder &);
  flatbuffers::Offset<HardSwishOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HardSwishOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HardSwishOptions> CreateHardSwishOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HardSwishOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalAndOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndOptionsBuilder &operator=(const LogicalAndOptionsBuilder &);
  flatbuffers::Offset<LogicalAndOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalNotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotOptionsBuilder &operator=(const LogicalNotOptionsBuilder &);
  flatbuffers::Offset<LogicalNotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct UnpackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
  }
  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnpackOptionsBuilder &operator=(const UnpackOptionsBuilder &);
  flatbuffers::Offset<UnpackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorDivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivOptionsBuilder &operator=(const FloorDivOptionsBuilder &);
  flatbuffers::Offset<FloorDivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquareOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareOptionsBuilder &operator=(const SquareOptionsBuilder &);
  flatbuffers::Offset<SquareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ZerosLikeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeOptionsBuilder &operator=(const ZerosLikeOptionsBuilder &);
  flatbuffers::Offset<ZerosLikeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FillOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillOptionsBuilder &operator=(const FillOptionsBuilder &);
  flatbuffers::Offset<FillOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorModOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModOptionsBuilder &operator=(const FloorModOptionsBuilder &);
  flatbuffers::Offset<FloorModOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RangeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeOptionsBuilder &operator=(const RangeOptionsBuilder &);
  flatbuffers::Offset<RangeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct LeakyReluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);
  }
  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluOptionsBuilder &operator=(const LeakyReluOptionsBuilder &);
  flatbuffers::Offset<LeakyReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquaredDifferenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceOptionsBuilder &operator=(const SquaredDifferenceOptionsBuilder &);
  flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  MirrorPadMode mode() const {
    return static_cast<MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct MirrorPadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(MirrorPadMode mode) {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MirrorPadOptionsBuilder &operator=(const MirrorPadOptionsBuilder &);
  flatbuffers::Offset<MirrorPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    MirrorPadMode mode = MirrorPadMode_REFLECT) {
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX_OUT_TYPE = 4
  };
  TensorType idx_out_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE) &&
           verifier.EndTable();
  }
};

struct UniqueOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx_out_type(TensorType idx_out_type) {
    fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueOptionsBuilder &operator=(const UniqueOptionsBuilder &);
  flatbuffers::Offset<UniqueOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType idx_out_type = TensorType_INT32) {
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReverseV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseV2OptionsBuilder &operator=(const ReverseV2OptionsBuilder &);
  flatbuffers::Offset<ReverseV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNOptionsBuilder &operator=(const AddNOptionsBuilder &);
  flatbuffers::Offset<AddNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GatherNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherNdOptionsBuilder &operator=(const GatherNdOptionsBuilder &);
  flatbuffers::Offset<GatherNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WhereOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhereOptionsBuilder &operator=(const WhereOptionsBuilder &);
  flatbuffers::Offset<WhereOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int32_t seq_dim() const {
    return GetField<int32_t>(VT_SEQ_DIM, 0);
  }
  int32_t batch_dim() const {
    return GetField<int32_t>(VT_BATCH_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQ_DIM) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIM) &&
           verifier.EndTable();
  }
};

struct ReverseSequenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceOptionsBuilder &operator=(const ReverseSequenceOptionsBuilder &);
  flatbuffers::Offset<ReverseSequenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seq_dim = 0,
    int32_t batch_dim = 0) {
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

struct MatrixDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MatrixDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixDiagOptionsBuilder &operator=(const MatrixDiagOptionsBuilder &);
  flatbuffers::Offset<MatrixDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiagOptions> CreateMatrixDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct QuantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_FRACTIONAL_LENGTH = 6,
    VT_SCALE_OUT = 8,
    VT_ZERO_POINT_OUTPUT = 10
  };
  QuantType type() const {
    return static_cast<QuantType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<int32_t> *fractional_length() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FRACTIONAL_LENGTH);
  }
  const flatbuffers::Vector<float> *scale_out() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE_OUT);
  }
  const flatbuffers::Vector<int32_t> *zero_point_output() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ZERO_POINT_OUTPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_FRACTIONAL_LENGTH) &&
           verifier.VerifyVector(fractional_length()) &&
           VerifyOffset(verifier, VT_SCALE_OUT) &&
           verifier.VerifyVector(scale_out()) &&
           VerifyOffset(verifier, VT_ZERO_POINT_OUTPUT) &&
           verifier.VerifyVector(zero_point_output()) &&
           verifier.EndTable();
  }
};

struct QuantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(QuantType type) {
    fbb_.AddElement<int8_t>(QuantizeOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_fractional_length(flatbuffers::Offset<flatbuffers::Vector<int32_t>> fractional_length) {
    fbb_.AddOffset(QuantizeOptions::VT_FRACTIONAL_LENGTH, fractional_length);
  }
  void add_scale_out(flatbuffers::Offset<flatbuffers::Vector<float>> scale_out) {
    fbb_.AddOffset(QuantizeOptions::VT_SCALE_OUT, scale_out);
  }
  void add_zero_point_output(flatbuffers::Offset<flatbuffers::Vector<int32_t>> zero_point_output) {
    fbb_.AddOffset(QuantizeOptions::VT_ZERO_POINT_OUTPUT, zero_point_output);
  }
  explicit QuantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizeOptionsBuilder &operator=(const QuantizeOptionsBuilder &);
  flatbuffers::Offset<QuantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    QuantType type = QuantType_SYMM,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> fractional_length = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale_out = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> zero_point_output = 0) {
  QuantizeOptionsBuilder builder_(_fbb);
  builder_.add_zero_point_output(zero_point_output);
  builder_.add_scale_out(scale_out);
  builder_.add_fractional_length(fractional_length);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizeOptions> CreateQuantizeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    QuantType type = QuantType_SYMM,
    const std::vector<int32_t> *fractional_length = nullptr,
    const std::vector<float> *scale_out = nullptr,
    const std::vector<int32_t> *zero_point_output = nullptr) {
  auto fractional_length__ = fractional_length ? _fbb.CreateVector<int32_t>(*fractional_length) : 0;
  auto scale_out__ = scale_out ? _fbb.CreateVector<float>(*scale_out) : 0;
  auto zero_point_output__ = zero_point_output ? _fbb.CreateVector<int32_t>(*zero_point_output) : 0;
  return tflite::v2::CreateQuantizeOptions(
      _fbb,
      type,
      fractional_length__,
      scale_out__,
      zero_point_output__);
}

struct MatrixSetDiagOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MatrixSetDiagOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MatrixSetDiagOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixSetDiagOptionsBuilder &operator=(const MatrixSetDiagOptionsBuilder &);
  flatbuffers::Offset<MatrixSetDiagOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixSetDiagOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixSetDiagOptions> CreateMatrixSetDiagOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MatrixSetDiagOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IfOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THEN_SUBGRAPH_INDEX = 4,
    VT_ELSE_SUBGRAPH_INDEX = 6
  };
  int32_t then_subgraph_index() const {
    return GetField<int32_t>(VT_THEN_SUBGRAPH_INDEX, 0);
  }
  int32_t else_subgraph_index() const {
    return GetField<int32_t>(VT_ELSE_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_THEN_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_ELSE_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct IfOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_then_subgraph_index(int32_t then_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
  }
  void add_else_subgraph_index(int32_t else_subgraph_index) {
    fbb_.AddElement<int32_t>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
  }
  explicit IfOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IfOptionsBuilder &operator=(const IfOptionsBuilder &);
  flatbuffers::Offset<IfOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfOptions> CreateIfOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t then_subgraph_index = 0,
    int32_t else_subgraph_index = 0) {
  IfOptionsBuilder builder_(_fbb);
  builder_.add_else_subgraph_index(else_subgraph_index);
  builder_.add_then_subgraph_index(then_subgraph_index);
  return builder_.Finish();
}

struct CallOnceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INIT_SUBGRAPH_INDEX = 4
  };
  int32_t init_subgraph_index() const {
    return GetField<int32_t>(VT_INIT_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INIT_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct CallOnceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_init_subgraph_index(int32_t init_subgraph_index) {
    fbb_.AddElement<int32_t>(CallOnceOptions::VT_INIT_SUBGRAPH_INDEX, init_subgraph_index, 0);
  }
  explicit CallOnceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOnceOptionsBuilder &operator=(const CallOnceOptionsBuilder &);
  flatbuffers::Offset<CallOnceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOnceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOnceOptions> CreateCallOnceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t init_subgraph_index = 0) {
  CallOnceOptionsBuilder builder_(_fbb);
  builder_.add_init_subgraph_index(init_subgraph_index);
  return builder_.Finish();
}

struct WhileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_SUBGRAPH_INDEX = 4,
    VT_BODY_SUBGRAPH_INDEX = 6
  };
  int32_t cond_subgraph_index() const {
    return GetField<int32_t>(VT_COND_SUBGRAPH_INDEX, 0);
  }
  int32_t body_subgraph_index() const {
    return GetField<int32_t>(VT_BODY_SUBGRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COND_SUBGRAPH_INDEX) &&
           VerifyField<int32_t>(verifier, VT_BODY_SUBGRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct WhileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond_subgraph_index(int32_t cond_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  void add_body_subgraph_index(int32_t body_subgraph_index) {
    fbb_.AddElement<int32_t>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  explicit WhileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhileOptionsBuilder &operator=(const WhileOptionsBuilder &);
  flatbuffers::Offset<WhileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhileOptions> CreateWhileOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cond_subgraph_index = 0,
    int32_t body_subgraph_index = 0) {
  WhileOptionsBuilder builder_(_fbb);
  builder_.add_body_subgraph_index(body_subgraph_index);
  builder_.add_cond_subgraph_index(cond_subgraph_index);
  return builder_.Finish();
}

struct NonMaxSuppressionV4Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NonMaxSuppressionV4OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV4OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV4OptionsBuilder &operator=(const NonMaxSuppressionV4OptionsBuilder &);
  flatbuffers::Offset<NonMaxSuppressionV4Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV4Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV4Options> CreateNonMaxSuppressionV4Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV4OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NonMaxSuppressionV5Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NonMaxSuppressionV5OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV5OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionV5OptionsBuilder &operator=(const NonMaxSuppressionV5OptionsBuilder &);
  flatbuffers::Offset<NonMaxSuppressionV5Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppressionV5Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppressionV5Options> CreateNonMaxSuppressionV5Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV5OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ScatterNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScatterNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterNdOptionsBuilder &operator=(const ScatterNdOptionsBuilder &);
  flatbuffers::Offset<ScatterNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdOptions> CreateScatterNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SelectV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SelectV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectV2OptionsBuilder &operator=(const SelectV2OptionsBuilder &);
  flatbuffers::Offset<SelectV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectV2Options> CreateSelectV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DensifyOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DensifyOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DensifyOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DensifyOptionsBuilder &operator=(const DensifyOptionsBuilder &);
  flatbuffers::Offset<DensifyOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DensifyOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DensifyOptions> CreateDensifyOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DensifyOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SegmentSumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SegmentSumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SegmentSumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SegmentSumOptionsBuilder &operator=(const SegmentSumOptionsBuilder &);
  flatbuffers::Offset<SegmentSumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SegmentSumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SegmentSumOptions> CreateSegmentSumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SegmentSumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchMatMulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADJ_X = 4,
    VT_ADJ_Y = 6,
    VT_ASYMMETRIC_QUANTIZE_INPUTS = 8
  };
  bool adj_x() const {
    return GetField<uint8_t>(VT_ADJ_X, 0) != 0;
  }
  bool adj_y() const {
    return GetField<uint8_t>(VT_ADJ_Y, 0) != 0;
  }
  bool asymmetric_quantize_inputs() const {
    return GetField<uint8_t>(VT_ASYMMETRIC_QUANTIZE_INPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_X) &&
           VerifyField<uint8_t>(verifier, VT_ADJ_Y) &&
           VerifyField<uint8_t>(verifier, VT_ASYMMETRIC_QUANTIZE_INPUTS) &&
           verifier.EndTable();
  }
};

struct BatchMatMulOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_adj_x(bool adj_x) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_X, static_cast<uint8_t>(adj_x), 0);
  }
  void add_adj_y(bool adj_y) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ADJ_Y, static_cast<uint8_t>(adj_y), 0);
  }
  void add_asymmetric_quantize_inputs(bool asymmetric_quantize_inputs) {
    fbb_.AddElement<uint8_t>(BatchMatMulOptions::VT_ASYMMETRIC_QUANTIZE_INPUTS, static_cast<uint8_t>(asymmetric_quantize_inputs), 0);
  }
  explicit BatchMatMulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchMatMulOptionsBuilder &operator=(const BatchMatMulOptionsBuilder &);
  flatbuffers::Offset<BatchMatMulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchMatMulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchMatMulOptions> CreateBatchMatMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool adj_x = false,
    bool adj_y = false,
    bool asymmetric_quantize_inputs = false) {
  BatchMatMulOptionsBuilder builder_(_fbb);
  builder_.add_asymmetric_quantize_inputs(asymmetric_quantize_inputs);
  builder_.add_adj_y(adj_y);
  builder_.add_adj_x(adj_x);
  return builder_.Finish();
}

struct CumsumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
           verifier.EndTable();
  }
};

struct CumsumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumsumOptions::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumsumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CumsumOptionsBuilder &operator=(const CumsumOptionsBuilder &);
  flatbuffers::Offset<CumsumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumsumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumsumOptions> CreateCumsumOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumsumOptionsBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

struct BroadcastToOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BroadcastToOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastToOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastToOptionsBuilder &operator=(const BroadcastToOptionsBuilder &);
  flatbuffers::Offset<BroadcastToOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastToOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastToOptions> CreateBroadcastToOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BroadcastToOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rfft2dOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Rfft2dOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Rfft2dOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Rfft2dOptionsBuilder &operator=(const Rfft2dOptionsBuilder &);
  flatbuffers::Offset<Rfft2dOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft2dOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft2dOptions> CreateRfft2dOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Rfft2dOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_ID = 4,
    VT_KEY_DTYPE = 6,
    VT_VALUE_DTYPE = 8
  };
  int32_t table_id() const {
    return GetField<int32_t>(VT_TABLE_ID, 0);
  }
  TensorType key_dtype() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_KEY_DTYPE, 0));
  }
  TensorType value_dtype() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_VALUE_DTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TABLE_ID) &&
           VerifyField<int8_t>(verifier, VT_KEY_DTYPE) &&
           VerifyField<int8_t>(verifier, VT_VALUE_DTYPE) &&
           verifier.EndTable();
  }
};

struct HashtableOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_id(int32_t table_id) {
    fbb_.AddElement<int32_t>(HashtableOptions::VT_TABLE_ID, table_id, 0);
  }
  void add_key_dtype(TensorType key_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_KEY_DTYPE, static_cast<int8_t>(key_dtype), 0);
  }
  void add_value_dtype(TensorType value_dtype) {
    fbb_.AddElement<int8_t>(HashtableOptions::VT_VALUE_DTYPE, static_cast<int8_t>(value_dtype), 0);
  }
  explicit HashtableOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableOptionsBuilder &operator=(const HashtableOptionsBuilder &);
  flatbuffers::Offset<HashtableOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableOptions> CreateHashtableOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t table_id = 0,
    TensorType key_dtype = TensorType_FLOAT32,
    TensorType value_dtype = TensorType_FLOAT32) {
  HashtableOptionsBuilder builder_(_fbb);
  builder_.add_table_id(table_id);
  builder_.add_value_dtype(value_dtype);
  builder_.add_key_dtype(key_dtype);
  return builder_.Finish();
}

struct HashtableFindOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HashtableFindOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableFindOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableFindOptionsBuilder &operator=(const HashtableFindOptionsBuilder &);
  flatbuffers::Offset<HashtableFindOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableFindOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableFindOptions> CreateHashtableFindOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableFindOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableImportOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HashtableImportOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableImportOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableImportOptionsBuilder &operator=(const HashtableImportOptionsBuilder &);
  flatbuffers::Offset<HashtableImportOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableImportOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableImportOptions> CreateHashtableImportOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableImportOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableSizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HashtableSizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableSizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableSizeOptionsBuilder &operator=(const HashtableSizeOptionsBuilder &);
  flatbuffers::Offset<HashtableSizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableSizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableSizeOptions> CreateHashtableSizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableSizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ENN_FlattenOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_END_AXIS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t end_axis() const {
    return GetField<int32_t>(VT_END_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_END_AXIS) &&
           verifier.EndTable();
  }
};

struct ENN_FlattenOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ENN_FlattenOptions::VT_AXIS, axis, 0);
  }
  void add_end_axis(int32_t end_axis) {
    fbb_.AddElement<int32_t>(ENN_FlattenOptions::VT_END_AXIS, end_axis, 0);
  }
  explicit ENN_FlattenOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_FlattenOptionsBuilder &operator=(const ENN_FlattenOptionsBuilder &);
  flatbuffers::Offset<ENN_FlattenOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_FlattenOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_FlattenOptions> CreateENN_FlattenOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t end_axis = 0) {
  ENN_FlattenOptionsBuilder builder_(_fbb);
  builder_.add_end_axis(end_axis);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct ENN_CropOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSET = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int32_t> *offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyVector(offset()) &&
           verifier.EndTable();
  }
};

struct ENN_CropOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ENN_CropOptions::VT_AXIS, axis, 0);
  }
  void add_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> offset) {
    fbb_.AddOffset(ENN_CropOptions::VT_OFFSET, offset);
  }
  explicit ENN_CropOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_CropOptionsBuilder &operator=(const ENN_CropOptionsBuilder &);
  flatbuffers::Offset<ENN_CropOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_CropOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_CropOptions> CreateENN_CropOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> offset = 0) {
  ENN_CropOptionsBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_CropOptions> CreateENN_CropOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *offset = nullptr) {
  auto offset__ = offset ? _fbb.CreateVector<int32_t>(*offset) : 0;
  return tflite::v2::CreateENN_CropOptions(
      _fbb,
      axis,
      offset__);
}

struct ENN_PermuteOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER = 4
  };
  const flatbuffers::Vector<int32_t> *order() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ORDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORDER) &&
           verifier.VerifyVector(order()) &&
           verifier.EndTable();
  }
};

struct ENN_PermuteOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(flatbuffers::Offset<flatbuffers::Vector<int32_t>> order) {
    fbb_.AddOffset(ENN_PermuteOptions::VT_ORDER, order);
  }
  explicit ENN_PermuteOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_PermuteOptionsBuilder &operator=(const ENN_PermuteOptionsBuilder &);
  flatbuffers::Offset<ENN_PermuteOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_PermuteOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_PermuteOptions> CreateENN_PermuteOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> order = 0) {
  ENN_PermuteOptionsBuilder builder_(_fbb);
  builder_.add_order(order);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_PermuteOptions> CreateENN_PermuteOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *order = nullptr) {
  auto order__ = order ? _fbb.CreateVector<int32_t>(*order) : 0;
  return tflite::v2::CreateENN_PermuteOptions(
      _fbb,
      order__);
}

struct ENN_PriorBoxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SIZE = 4,
    VT_MAX_SIZE = 6,
    VT_ASPECT_RATIO = 8,
    VT_FLIP = 10,
    VT_CLIP = 12,
    VT_VARIANCE = 14,
    VT_OFFSET = 16,
    VT_IMG_H = 18,
    VT_IMG_W = 20,
    VT_STEP_H = 22,
    VT_STEP_W = 24
  };
  const flatbuffers::Vector<float> *min_size() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN_SIZE);
  }
  const flatbuffers::Vector<float> *max_size() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX_SIZE);
  }
  const flatbuffers::Vector<float> *aspect_ratio() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIO);
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 0) != 0;
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 0) != 0;
  }
  const flatbuffers::Vector<float> *variance() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCE);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  int32_t img_h() const {
    return GetField<int32_t>(VT_IMG_H, 0);
  }
  int32_t img_w() const {
    return GetField<int32_t>(VT_IMG_W, 0);
  }
  float step_h() const {
    return GetField<float>(VT_STEP_H, 0.0f);
  }
  float step_w() const {
    return GetField<float>(VT_STEP_W, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_SIZE) &&
           verifier.VerifyVector(min_size()) &&
           VerifyOffset(verifier, VT_MAX_SIZE) &&
           verifier.VerifyVector(max_size()) &&
           VerifyOffset(verifier, VT_ASPECT_RATIO) &&
           verifier.VerifyVector(aspect_ratio()) &&
           VerifyField<uint8_t>(verifier, VT_FLIP) &&
           VerifyField<uint8_t>(verifier, VT_CLIP) &&
           VerifyOffset(verifier, VT_VARIANCE) &&
           verifier.VerifyVector(variance()) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           VerifyField<int32_t>(verifier, VT_IMG_H) &&
           VerifyField<int32_t>(verifier, VT_IMG_W) &&
           VerifyField<float>(verifier, VT_STEP_H) &&
           VerifyField<float>(verifier, VT_STEP_W) &&
           verifier.EndTable();
  }
};

struct ENN_PriorBoxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_size(flatbuffers::Offset<flatbuffers::Vector<float>> min_size) {
    fbb_.AddOffset(ENN_PriorBoxOptions::VT_MIN_SIZE, min_size);
  }
  void add_max_size(flatbuffers::Offset<flatbuffers::Vector<float>> max_size) {
    fbb_.AddOffset(ENN_PriorBoxOptions::VT_MAX_SIZE, max_size);
  }
  void add_aspect_ratio(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratio) {
    fbb_.AddOffset(ENN_PriorBoxOptions::VT_ASPECT_RATIO, aspect_ratio);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(ENN_PriorBoxOptions::VT_FLIP, static_cast<uint8_t>(flip), 0);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(ENN_PriorBoxOptions::VT_CLIP, static_cast<uint8_t>(clip), 0);
  }
  void add_variance(flatbuffers::Offset<flatbuffers::Vector<float>> variance) {
    fbb_.AddOffset(ENN_PriorBoxOptions::VT_VARIANCE, variance);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(ENN_PriorBoxOptions::VT_OFFSET, offset, 0.0f);
  }
  void add_img_h(int32_t img_h) {
    fbb_.AddElement<int32_t>(ENN_PriorBoxOptions::VT_IMG_H, img_h, 0);
  }
  void add_img_w(int32_t img_w) {
    fbb_.AddElement<int32_t>(ENN_PriorBoxOptions::VT_IMG_W, img_w, 0);
  }
  void add_step_h(float step_h) {
    fbb_.AddElement<float>(ENN_PriorBoxOptions::VT_STEP_H, step_h, 0.0f);
  }
  void add_step_w(float step_w) {
    fbb_.AddElement<float>(ENN_PriorBoxOptions::VT_STEP_W, step_w, 0.0f);
  }
  explicit ENN_PriorBoxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_PriorBoxOptionsBuilder &operator=(const ENN_PriorBoxOptionsBuilder &);
  flatbuffers::Offset<ENN_PriorBoxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_PriorBoxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_PriorBoxOptions> CreateENN_PriorBoxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratio = 0,
    bool flip = false,
    bool clip = false,
    flatbuffers::Offset<flatbuffers::Vector<float>> variance = 0,
    float offset = 0.0f,
    int32_t img_h = 0,
    int32_t img_w = 0,
    float step_h = 0.0f,
    float step_w = 0.0f) {
  ENN_PriorBoxOptionsBuilder builder_(_fbb);
  builder_.add_step_w(step_w);
  builder_.add_step_h(step_h);
  builder_.add_img_w(img_w);
  builder_.add_img_h(img_h);
  builder_.add_offset(offset);
  builder_.add_variance(variance);
  builder_.add_aspect_ratio(aspect_ratio);
  builder_.add_max_size(max_size);
  builder_.add_min_size(min_size);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_PriorBoxOptions> CreateENN_PriorBoxOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min_size = nullptr,
    const std::vector<float> *max_size = nullptr,
    const std::vector<float> *aspect_ratio = nullptr,
    bool flip = false,
    bool clip = false,
    const std::vector<float> *variance = nullptr,
    float offset = 0.0f,
    int32_t img_h = 0,
    int32_t img_w = 0,
    float step_h = 0.0f,
    float step_w = 0.0f) {
  auto min_size__ = min_size ? _fbb.CreateVector<float>(*min_size) : 0;
  auto max_size__ = max_size ? _fbb.CreateVector<float>(*max_size) : 0;
  auto aspect_ratio__ = aspect_ratio ? _fbb.CreateVector<float>(*aspect_ratio) : 0;
  auto variance__ = variance ? _fbb.CreateVector<float>(*variance) : 0;
  return tflite::v2::CreateENN_PriorBoxOptions(
      _fbb,
      min_size__,
      max_size__,
      aspect_ratio__,
      flip,
      clip,
      variance__,
      offset,
      img_h,
      img_w,
      step_h,
      step_w);
}

struct ENN_DetectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_CLASSES = 4,
    VT_SHARE_LOCATION = 6,
    VT_BACKGROUND_LABEL_ID = 8,
    VT_NMS_THRESHOLD = 10,
    VT_NMS_TOP_K = 12,
    VT_NMS_ETA = 14,
    VT_CODE_TYPE = 16,
    VT_VARIANCE_ENCODED_IN_TARGET = 18,
    VT_KEEP_TOP_K = 20,
    VT_CONFIDENCE_THRESHOLD = 22
  };
  int32_t num_classes() const {
    return GetField<int32_t>(VT_NUM_CLASSES, 0);
  }
  bool share_location() const {
    return GetField<uint8_t>(VT_SHARE_LOCATION, 0) != 0;
  }
  int32_t background_label_id() const {
    return GetField<int32_t>(VT_BACKGROUND_LABEL_ID, 0);
  }
  float nms_threshold() const {
    return GetField<float>(VT_NMS_THRESHOLD, 0.0f);
  }
  int32_t nms_top_k() const {
    return GetField<int32_t>(VT_NMS_TOP_K, 0);
  }
  float nms_eta() const {
    return GetField<float>(VT_NMS_ETA, 0.0f);
  }
  PriorBoxCodingType code_type() const {
    return static_cast<PriorBoxCodingType>(GetField<int8_t>(VT_CODE_TYPE, 0));
  }
  bool variance_encoded_in_target() const {
    return GetField<uint8_t>(VT_VARIANCE_ENCODED_IN_TARGET, 0) != 0;
  }
  int32_t keep_top_k() const {
    return GetField<int32_t>(VT_KEEP_TOP_K, 0);
  }
  float confidence_threshold() const {
    return GetField<float>(VT_CONFIDENCE_THRESHOLD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CLASSES) &&
           VerifyField<uint8_t>(verifier, VT_SHARE_LOCATION) &&
           VerifyField<int32_t>(verifier, VT_BACKGROUND_LABEL_ID) &&
           VerifyField<float>(verifier, VT_NMS_THRESHOLD) &&
           VerifyField<int32_t>(verifier, VT_NMS_TOP_K) &&
           VerifyField<float>(verifier, VT_NMS_ETA) &&
           VerifyField<int8_t>(verifier, VT_CODE_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_VARIANCE_ENCODED_IN_TARGET) &&
           VerifyField<int32_t>(verifier, VT_KEEP_TOP_K) &&
           VerifyField<float>(verifier, VT_CONFIDENCE_THRESHOLD) &&
           verifier.EndTable();
  }
};

struct ENN_DetectionOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_classes(int32_t num_classes) {
    fbb_.AddElement<int32_t>(ENN_DetectionOptions::VT_NUM_CLASSES, num_classes, 0);
  }
  void add_share_location(bool share_location) {
    fbb_.AddElement<uint8_t>(ENN_DetectionOptions::VT_SHARE_LOCATION, static_cast<uint8_t>(share_location), 0);
  }
  void add_background_label_id(int32_t background_label_id) {
    fbb_.AddElement<int32_t>(ENN_DetectionOptions::VT_BACKGROUND_LABEL_ID, background_label_id, 0);
  }
  void add_nms_threshold(float nms_threshold) {
    fbb_.AddElement<float>(ENN_DetectionOptions::VT_NMS_THRESHOLD, nms_threshold, 0.0f);
  }
  void add_nms_top_k(int32_t nms_top_k) {
    fbb_.AddElement<int32_t>(ENN_DetectionOptions::VT_NMS_TOP_K, nms_top_k, 0);
  }
  void add_nms_eta(float nms_eta) {
    fbb_.AddElement<float>(ENN_DetectionOptions::VT_NMS_ETA, nms_eta, 0.0f);
  }
  void add_code_type(PriorBoxCodingType code_type) {
    fbb_.AddElement<int8_t>(ENN_DetectionOptions::VT_CODE_TYPE, static_cast<int8_t>(code_type), 0);
  }
  void add_variance_encoded_in_target(bool variance_encoded_in_target) {
    fbb_.AddElement<uint8_t>(ENN_DetectionOptions::VT_VARIANCE_ENCODED_IN_TARGET, static_cast<uint8_t>(variance_encoded_in_target), 0);
  }
  void add_keep_top_k(int32_t keep_top_k) {
    fbb_.AddElement<int32_t>(ENN_DetectionOptions::VT_KEEP_TOP_K, keep_top_k, 0);
  }
  void add_confidence_threshold(float confidence_threshold) {
    fbb_.AddElement<float>(ENN_DetectionOptions::VT_CONFIDENCE_THRESHOLD, confidence_threshold, 0.0f);
  }
  explicit ENN_DetectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_DetectionOptionsBuilder &operator=(const ENN_DetectionOptionsBuilder &);
  flatbuffers::Offset<ENN_DetectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_DetectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_DetectionOptions> CreateENN_DetectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_classes = 0,
    bool share_location = false,
    int32_t background_label_id = 0,
    float nms_threshold = 0.0f,
    int32_t nms_top_k = 0,
    float nms_eta = 0.0f,
    PriorBoxCodingType code_type = PriorBoxCodingType_CORNER,
    bool variance_encoded_in_target = false,
    int32_t keep_top_k = 0,
    float confidence_threshold = 0.0f) {
  ENN_DetectionOptionsBuilder builder_(_fbb);
  builder_.add_confidence_threshold(confidence_threshold);
  builder_.add_keep_top_k(keep_top_k);
  builder_.add_nms_eta(nms_eta);
  builder_.add_nms_top_k(nms_top_k);
  builder_.add_nms_threshold(nms_threshold);
  builder_.add_background_label_id(background_label_id);
  builder_.add_num_classes(num_classes);
  builder_.add_variance_encoded_in_target(variance_encoded_in_target);
  builder_.add_code_type(code_type);
  builder_.add_share_location(share_location);
  return builder_.Finish();
}

struct ENN_PowerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct ENN_PowerOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(ENN_PowerOptions::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ENN_PowerOptions::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(ENN_PowerOptions::VT_SHIFT, shift, 0.0f);
  }
  explicit ENN_PowerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_PowerOptionsBuilder &operator=(const ENN_PowerOptionsBuilder &);
  flatbuffers::Offset<ENN_PowerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_PowerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_PowerOptions> CreateENN_PowerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  ENN_PowerOptionsBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

struct ENN_ScaleOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_NUM_AXES = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t num_axes() const {
    return GetField<int32_t>(VT_NUM_AXES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_NUM_AXES) &&
           verifier.EndTable();
  }
};

struct ENN_ScaleOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ENN_ScaleOptions::VT_AXIS, axis, 0);
  }
  void add_num_axes(int32_t num_axes) {
    fbb_.AddElement<int32_t>(ENN_ScaleOptions::VT_NUM_AXES, num_axes, 0);
  }
  explicit ENN_ScaleOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_ScaleOptionsBuilder &operator=(const ENN_ScaleOptionsBuilder &);
  flatbuffers::Offset<ENN_ScaleOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_ScaleOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_ScaleOptions> CreateENN_ScaleOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t num_axes = 0) {
  ENN_ScaleOptionsBuilder builder_(_fbb);
  builder_.add_num_axes(num_axes);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct ENN_TFliteDetectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX_DETECTIONS = 4,
    VT_MAX_CLASSES_PER_DETECTION = 6,
    VT_NMS_SCORE_THRESHOLD = 8,
    VT_NMS_IOU_THRESHOLD = 10,
    VT_NUM_CLASSES = 12,
    VT_Y_SCALE = 14,
    VT_X_SCALE = 16,
    VT_H_SCALE = 18,
    VT_W_SCALE = 20
  };
  uint32_t max_detections() const {
    return GetField<uint32_t>(VT_MAX_DETECTIONS, 0);
  }
  uint32_t max_classes_per_detection() const {
    return GetField<uint32_t>(VT_MAX_CLASSES_PER_DETECTION, 0);
  }
  float nms_score_threshold() const {
    return GetField<float>(VT_NMS_SCORE_THRESHOLD, 0.0f);
  }
  float nms_iou_threshold() const {
    return GetField<float>(VT_NMS_IOU_THRESHOLD, 0.0f);
  }
  uint32_t num_classes() const {
    return GetField<uint32_t>(VT_NUM_CLASSES, 0);
  }
  float y_scale() const {
    return GetField<float>(VT_Y_SCALE, 0.0f);
  }
  float x_scale() const {
    return GetField<float>(VT_X_SCALE, 0.0f);
  }
  float h_scale() const {
    return GetField<float>(VT_H_SCALE, 0.0f);
  }
  float w_scale() const {
    return GetField<float>(VT_W_SCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAX_DETECTIONS) &&
           VerifyField<uint32_t>(verifier, VT_MAX_CLASSES_PER_DETECTION) &&
           VerifyField<float>(verifier, VT_NMS_SCORE_THRESHOLD) &&
           VerifyField<float>(verifier, VT_NMS_IOU_THRESHOLD) &&
           VerifyField<uint32_t>(verifier, VT_NUM_CLASSES) &&
           VerifyField<float>(verifier, VT_Y_SCALE) &&
           VerifyField<float>(verifier, VT_X_SCALE) &&
           VerifyField<float>(verifier, VT_H_SCALE) &&
           VerifyField<float>(verifier, VT_W_SCALE) &&
           verifier.EndTable();
  }
};

struct ENN_TFliteDetectionOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max_detections(uint32_t max_detections) {
    fbb_.AddElement<uint32_t>(ENN_TFliteDetectionOptions::VT_MAX_DETECTIONS, max_detections, 0);
  }
  void add_max_classes_per_detection(uint32_t max_classes_per_detection) {
    fbb_.AddElement<uint32_t>(ENN_TFliteDetectionOptions::VT_MAX_CLASSES_PER_DETECTION, max_classes_per_detection, 0);
  }
  void add_nms_score_threshold(float nms_score_threshold) {
    fbb_.AddElement<float>(ENN_TFliteDetectionOptions::VT_NMS_SCORE_THRESHOLD, nms_score_threshold, 0.0f);
  }
  void add_nms_iou_threshold(float nms_iou_threshold) {
    fbb_.AddElement<float>(ENN_TFliteDetectionOptions::VT_NMS_IOU_THRESHOLD, nms_iou_threshold, 0.0f);
  }
  void add_num_classes(uint32_t num_classes) {
    fbb_.AddElement<uint32_t>(ENN_TFliteDetectionOptions::VT_NUM_CLASSES, num_classes, 0);
  }
  void add_y_scale(float y_scale) {
    fbb_.AddElement<float>(ENN_TFliteDetectionOptions::VT_Y_SCALE, y_scale, 0.0f);
  }
  void add_x_scale(float x_scale) {
    fbb_.AddElement<float>(ENN_TFliteDetectionOptions::VT_X_SCALE, x_scale, 0.0f);
  }
  void add_h_scale(float h_scale) {
    fbb_.AddElement<float>(ENN_TFliteDetectionOptions::VT_H_SCALE, h_scale, 0.0f);
  }
  void add_w_scale(float w_scale) {
    fbb_.AddElement<float>(ENN_TFliteDetectionOptions::VT_W_SCALE, w_scale, 0.0f);
  }
  explicit ENN_TFliteDetectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_TFliteDetectionOptionsBuilder &operator=(const ENN_TFliteDetectionOptionsBuilder &);
  flatbuffers::Offset<ENN_TFliteDetectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_TFliteDetectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_TFliteDetectionOptions> CreateENN_TFliteDetectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t max_detections = 0,
    uint32_t max_classes_per_detection = 0,
    float nms_score_threshold = 0.0f,
    float nms_iou_threshold = 0.0f,
    uint32_t num_classes = 0,
    float y_scale = 0.0f,
    float x_scale = 0.0f,
    float h_scale = 0.0f,
    float w_scale = 0.0f) {
  ENN_TFliteDetectionOptionsBuilder builder_(_fbb);
  builder_.add_w_scale(w_scale);
  builder_.add_h_scale(h_scale);
  builder_.add_x_scale(x_scale);
  builder_.add_y_scale(y_scale);
  builder_.add_num_classes(num_classes);
  builder_.add_nms_iou_threshold(nms_iou_threshold);
  builder_.add_nms_score_threshold(nms_score_threshold);
  builder_.add_max_classes_per_detection(max_classes_per_detection);
  builder_.add_max_detections(max_detections);
  return builder_.Finish();
}

struct ENN_MeanOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4
  };
  int32_t keep_dims() const {
    return GetField<int32_t>(VT_KEEP_DIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
};

struct ENN_MeanOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(int32_t keep_dims) {
    fbb_.AddElement<int32_t>(ENN_MeanOptions::VT_KEEP_DIMS, keep_dims, 0);
  }
  explicit ENN_MeanOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_MeanOptionsBuilder &operator=(const ENN_MeanOptionsBuilder &);
  flatbuffers::Offset<ENN_MeanOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_MeanOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_MeanOptions> CreateENN_MeanOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t keep_dims = 0) {
  ENN_MeanOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct ENN_TFliteSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ENN_TFliteSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ENN_TFliteSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_TFliteSliceOptionsBuilder &operator=(const ENN_TFliteSliceOptionsBuilder &);
  flatbuffers::Offset<ENN_TFliteSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_TFliteSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_TFliteSliceOptions> CreateENN_TFliteSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ENN_TFliteSliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ENN_ReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVE_SLOPE = 4
  };
  float negative_slope() const {
    return GetField<float>(VT_NEGATIVE_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVE_SLOPE) &&
           verifier.EndTable();
  }
};

struct ENN_ReluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negative_slope(float negative_slope) {
    fbb_.AddElement<float>(ENN_ReluOptions::VT_NEGATIVE_SLOPE, negative_slope, 0.0f);
  }
  explicit ENN_ReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_ReluOptionsBuilder &operator=(const ENN_ReluOptionsBuilder &);
  flatbuffers::Offset<ENN_ReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_ReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_ReluOptions> CreateENN_ReluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negative_slope = 0.0f) {
  ENN_ReluOptionsBuilder builder_(_fbb);
  builder_.add_negative_slope(negative_slope);
  return builder_.Finish();
}

struct ENN_EluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct ENN_EluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ENN_EluOptions::VT_ALPHA, alpha, 0.0f);
  }
  explicit ENN_EluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_EluOptionsBuilder &operator=(const ENN_EluOptionsBuilder &);
  flatbuffers::Offset<ENN_EluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_EluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_EluOptions> CreateENN_EluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  ENN_EluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct ENN_ClipOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6
  };
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) &&
           verifier.EndTable();
  }
};

struct ENN_ClipOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(ENN_ClipOptions::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(ENN_ClipOptions::VT_MAX, max, 0.0f);
  }
  explicit ENN_ClipOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_ClipOptionsBuilder &operator=(const ENN_ClipOptionsBuilder &);
  flatbuffers::Offset<ENN_ClipOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_ClipOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_ClipOptions> CreateENN_ClipOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f) {
  ENN_ClipOptionsBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

struct ENN_CFUOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLS_IN_CELL = 4,
    VT_LINES_IN_CELL = 6,
    VT_INTERLEAVED_SLICES = 8
  };
  int32_t cols_in_cell() const {
    return GetField<int32_t>(VT_COLS_IN_CELL, 0);
  }
  int32_t lines_in_cell() const {
    return GetField<int32_t>(VT_LINES_IN_CELL, 0);
  }
  int32_t interleaved_slices() const {
    return GetField<int32_t>(VT_INTERLEAVED_SLICES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLS_IN_CELL) &&
           VerifyField<int32_t>(verifier, VT_LINES_IN_CELL) &&
           VerifyField<int32_t>(verifier, VT_INTERLEAVED_SLICES) &&
           verifier.EndTable();
  }
};

struct ENN_CFUOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cols_in_cell(int32_t cols_in_cell) {
    fbb_.AddElement<int32_t>(ENN_CFUOptions::VT_COLS_IN_CELL, cols_in_cell, 0);
  }
  void add_lines_in_cell(int32_t lines_in_cell) {
    fbb_.AddElement<int32_t>(ENN_CFUOptions::VT_LINES_IN_CELL, lines_in_cell, 0);
  }
  void add_interleaved_slices(int32_t interleaved_slices) {
    fbb_.AddElement<int32_t>(ENN_CFUOptions::VT_INTERLEAVED_SLICES, interleaved_slices, 0);
  }
  explicit ENN_CFUOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_CFUOptionsBuilder &operator=(const ENN_CFUOptionsBuilder &);
  flatbuffers::Offset<ENN_CFUOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_CFUOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_CFUOptions> CreateENN_CFUOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cols_in_cell = 0,
    int32_t lines_in_cell = 0,
    int32_t interleaved_slices = 0) {
  ENN_CFUOptionsBuilder builder_(_fbb);
  builder_.add_interleaved_slices(interleaved_slices);
  builder_.add_lines_in_cell(lines_in_cell);
  builder_.add_cols_in_cell(cols_in_cell);
  return builder_.Finish();
}

struct ENN_InverseCFUOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLS_IN_CELL = 4,
    VT_LINES_IN_CELL = 6,
    VT_INTERLEAVED_SLICES = 8
  };
  int32_t cols_in_cell() const {
    return GetField<int32_t>(VT_COLS_IN_CELL, 0);
  }
  int32_t lines_in_cell() const {
    return GetField<int32_t>(VT_LINES_IN_CELL, 0);
  }
  int32_t interleaved_slices() const {
    return GetField<int32_t>(VT_INTERLEAVED_SLICES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLS_IN_CELL) &&
           VerifyField<int32_t>(verifier, VT_LINES_IN_CELL) &&
           VerifyField<int32_t>(verifier, VT_INTERLEAVED_SLICES) &&
           verifier.EndTable();
  }
};

struct ENN_InverseCFUOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cols_in_cell(int32_t cols_in_cell) {
    fbb_.AddElement<int32_t>(ENN_InverseCFUOptions::VT_COLS_IN_CELL, cols_in_cell, 0);
  }
  void add_lines_in_cell(int32_t lines_in_cell) {
    fbb_.AddElement<int32_t>(ENN_InverseCFUOptions::VT_LINES_IN_CELL, lines_in_cell, 0);
  }
  void add_interleaved_slices(int32_t interleaved_slices) {
    fbb_.AddElement<int32_t>(ENN_InverseCFUOptions::VT_INTERLEAVED_SLICES, interleaved_slices, 0);
  }
  explicit ENN_InverseCFUOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_InverseCFUOptionsBuilder &operator=(const ENN_InverseCFUOptionsBuilder &);
  flatbuffers::Offset<ENN_InverseCFUOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_InverseCFUOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_InverseCFUOptions> CreateENN_InverseCFUOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t cols_in_cell = 0,
    int32_t lines_in_cell = 0,
    int32_t interleaved_slices = 0) {
  ENN_InverseCFUOptionsBuilder builder_(_fbb);
  builder_.add_interleaved_slices(interleaved_slices);
  builder_.add_lines_in_cell(lines_in_cell);
  builder_.add_cols_in_cell(cols_in_cell);
  return builder_.Finish();
}

struct ENN_NormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEAN = 4,
    VT_SCALE = 6
  };
  const flatbuffers::Vector<float> *mean() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MEAN);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyVector(mean()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
};

struct ENN_NormalizationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mean(flatbuffers::Offset<flatbuffers::Vector<float>> mean) {
    fbb_.AddOffset(ENN_NormalizationOptions::VT_MEAN, mean);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(ENN_NormalizationOptions::VT_SCALE, scale);
  }
  explicit ENN_NormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_NormalizationOptionsBuilder &operator=(const ENN_NormalizationOptionsBuilder &);
  flatbuffers::Offset<ENN_NormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_NormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_NormalizationOptions> CreateENN_NormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> mean = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0) {
  ENN_NormalizationOptionsBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_mean(mean);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_NormalizationOptions> CreateENN_NormalizationOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *mean = nullptr,
    const std::vector<float> *scale = nullptr) {
  auto mean__ = mean ? _fbb.CreateVector<float>(*mean) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return tflite::v2::CreateENN_NormalizationOptions(
      _fbb,
      mean__,
      scale__);
}

struct ENN_NPUOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA = 4,
    VT_NAME = 6
  };
  const flatbuffers::Vector<uint8_t> *metadata() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct ENN_NPUOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> metadata) {
    fbb_.AddOffset(ENN_NPUOptions::VT_METADATA, metadata);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ENN_NPUOptions::VT_NAME, name);
  }
  explicit ENN_NPUOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_NPUOptionsBuilder &operator=(const ENN_NPUOptionsBuilder &);
  flatbuffers::Offset<ENN_NPUOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_NPUOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_NPUOptions> CreateENN_NPUOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> metadata = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  ENN_NPUOptionsBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_metadata(metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_NPUOptions> CreateENN_NPUOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *metadata = nullptr,
    const char *name = nullptr) {
  auto metadata__ = metadata ? _fbb.CreateVector<uint8_t>(*metadata) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::v2::CreateENN_NPUOptions(
      _fbb,
      metadata__,
      name__);
}

struct ENN_DSPOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA = 4,
    VT_NAME = 6
  };
  const flatbuffers::Vector<uint8_t> *metadata() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct ENN_DSPOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> metadata) {
    fbb_.AddOffset(ENN_DSPOptions::VT_METADATA, metadata);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ENN_DSPOptions::VT_NAME, name);
  }
  explicit ENN_DSPOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_DSPOptionsBuilder &operator=(const ENN_DSPOptionsBuilder &);
  flatbuffers::Offset<ENN_DSPOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_DSPOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_DSPOptions> CreateENN_DSPOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> metadata = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  ENN_DSPOptionsBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_metadata(metadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_DSPOptions> CreateENN_DSPOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *metadata = nullptr,
    const char *name = nullptr) {
  auto metadata__ = metadata ? _fbb.CreateVector<uint8_t>(*metadata) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::v2::CreateENN_DSPOptions(
      _fbb,
      metadata__,
      name__);
}

struct ENN_UNIFIED_DEVICE_BinaryOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA = 4,
    VT_TENSOR_NAME = 6,
    VT_TARGET_HW = 8,
    VT_START = 10,
    VT_END = 12,
    VT_TENSOR_CONNECTIONS = 14
  };
  const flatbuffers::Vector<uint8_t> *metadata() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  const flatbuffers::String *tensor_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TENSOR_NAME);
  }
  TargetHw target_hw() const {
    return static_cast<TargetHw>(GetField<int8_t>(VT_TARGET_HW, 0));
  }
  bool start() const {
    return GetField<uint8_t>(VT_START, 0) != 0;
  }
  bool end() const {
    return GetField<uint8_t>(VT_END, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *tensor_connections() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TENSOR_CONNECTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           VerifyOffset(verifier, VT_TENSOR_NAME) &&
           verifier.VerifyString(tensor_name()) &&
           VerifyField<int8_t>(verifier, VT_TARGET_HW) &&
           VerifyField<uint8_t>(verifier, VT_START) &&
           VerifyField<uint8_t>(verifier, VT_END) &&
           VerifyOffset(verifier, VT_TENSOR_CONNECTIONS) &&
           verifier.VerifyVector(tensor_connections()) &&
           verifier.EndTable();
  }
};

struct ENN_UNIFIED_DEVICE_BinaryOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> metadata) {
    fbb_.AddOffset(ENN_UNIFIED_DEVICE_BinaryOptions::VT_METADATA, metadata);
  }
  void add_tensor_name(flatbuffers::Offset<flatbuffers::String> tensor_name) {
    fbb_.AddOffset(ENN_UNIFIED_DEVICE_BinaryOptions::VT_TENSOR_NAME, tensor_name);
  }
  void add_target_hw(TargetHw target_hw) {
    fbb_.AddElement<int8_t>(ENN_UNIFIED_DEVICE_BinaryOptions::VT_TARGET_HW, static_cast<int8_t>(target_hw), 0);
  }
  void add_start(bool start) {
    fbb_.AddElement<uint8_t>(ENN_UNIFIED_DEVICE_BinaryOptions::VT_START, static_cast<uint8_t>(start), 0);
  }
  void add_end(bool end) {
    fbb_.AddElement<uint8_t>(ENN_UNIFIED_DEVICE_BinaryOptions::VT_END, static_cast<uint8_t>(end), 0);
  }
  void add_tensor_connections(flatbuffers::Offset<flatbuffers::Vector<int32_t>> tensor_connections) {
    fbb_.AddOffset(ENN_UNIFIED_DEVICE_BinaryOptions::VT_TENSOR_CONNECTIONS, tensor_connections);
  }
  explicit ENN_UNIFIED_DEVICE_BinaryOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_UNIFIED_DEVICE_BinaryOptionsBuilder &operator=(const ENN_UNIFIED_DEVICE_BinaryOptionsBuilder &);
  flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions> CreateENN_UNIFIED_DEVICE_BinaryOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> metadata = 0,
    flatbuffers::Offset<flatbuffers::String> tensor_name = 0,
    TargetHw target_hw = TargetHw_NONE,
    bool start = false,
    bool end = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> tensor_connections = 0) {
  ENN_UNIFIED_DEVICE_BinaryOptionsBuilder builder_(_fbb);
  builder_.add_tensor_connections(tensor_connections);
  builder_.add_tensor_name(tensor_name);
  builder_.add_metadata(metadata);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_target_hw(target_hw);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions> CreateENN_UNIFIED_DEVICE_BinaryOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *metadata = nullptr,
    const char *tensor_name = nullptr,
    TargetHw target_hw = TargetHw_NONE,
    bool start = false,
    bool end = false,
    const std::vector<int32_t> *tensor_connections = nullptr) {
  auto metadata__ = metadata ? _fbb.CreateVector<uint8_t>(*metadata) : 0;
  auto tensor_name__ = tensor_name ? _fbb.CreateString(tensor_name) : 0;
  auto tensor_connections__ = tensor_connections ? _fbb.CreateVector<int32_t>(*tensor_connections) : 0;
  return tflite::v2::CreateENN_UNIFIED_DEVICE_BinaryOptions(
      _fbb,
      metadata__,
      tensor_name__,
      target_hw,
      start,
      end,
      tensor_connections__);
}

struct ENN_UNIFIED_DEVICEOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTIONS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions>> *options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions>> *>(VT_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyVector(options()) &&
           verifier.VerifyVectorOfTables(options()) &&
           verifier.EndTable();
  }
};

struct ENN_UNIFIED_DEVICEOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions>>> options) {
    fbb_.AddOffset(ENN_UNIFIED_DEVICEOptions::VT_OPTIONS, options);
  }
  explicit ENN_UNIFIED_DEVICEOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ENN_UNIFIED_DEVICEOptionsBuilder &operator=(const ENN_UNIFIED_DEVICEOptionsBuilder &);
  flatbuffers::Offset<ENN_UNIFIED_DEVICEOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ENN_UNIFIED_DEVICEOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ENN_UNIFIED_DEVICEOptions> CreateENN_UNIFIED_DEVICEOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions>>> options = 0) {
  ENN_UNIFIED_DEVICEOptionsBuilder builder_(_fbb);
  builder_.add_options(options);
  return builder_.Finish();
}

inline flatbuffers::Offset<ENN_UNIFIED_DEVICEOptions> CreateENN_UNIFIED_DEVICEOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions>> *options = nullptr) {
  auto options__ = options ? _fbb.CreateVector<flatbuffers::Offset<ENN_UNIFIED_DEVICE_BinaryOptions>>(*options) : 0;
  return tflite::v2::CreateENN_UNIFIED_DEVICEOptions(
      _fbb,
      options__);
}

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPRECATED_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8,
    VT_BUILTIN_CODE = 10
  };
  int8_t deprecated_builtin_code() const {
    return GetField<int8_t>(VT_DEPRECATED_BUILTIN_CODE, 0);
  }
  const flatbuffers::String *custom_code() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 1);
  }
  BuiltinOperator builtin_code() const {
    return static_cast<BuiltinOperator>(GetField<int32_t>(VT_BUILTIN_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DEPRECATED_BUILTIN_CODE) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) &&
           verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_BUILTIN_CODE) &&
           verifier.EndTable();
  }
};

struct OperatorCodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deprecated_builtin_code(int8_t deprecated_builtin_code) {
    fbb_.AddElement<int8_t>(OperatorCode::VT_DEPRECATED_BUILTIN_CODE, deprecated_builtin_code, 0);
  }
  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  void add_builtin_code(BuiltinOperator builtin_code) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int32_t>(builtin_code), 0);
  }
  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorCodeBuilder &operator=(const OperatorCodeBuilder &);
  flatbuffers::Offset<OperatorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t deprecated_builtin_code = 0,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0,
    int32_t version = 1,
    BuiltinOperator builtin_code = BuiltinOperator_ADD) {
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_builtin_code(builtin_code);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_deprecated_builtin_code(deprecated_builtin_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t deprecated_builtin_code = 0,
    const char *custom_code = nullptr,
    int32_t version = 1,
    BuiltinOperator builtin_code = BuiltinOperator_ADD) {
  auto custom_code__ = custom_code ? _fbb.CreateString(custom_code) : 0;
  return tflite::v2::CreateOperatorCode(
      _fbb,
      deprecated_builtin_code,
      custom_code__,
      version,
      builtin_code);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18,
    VT_INTERMEDIATES = 20,
    VT_TARGET_HW = 22
  };
  uint32_t opcode_index() const {
    return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  BuiltinOptions builtin_options_type() const {
    return static_cast<BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void *builtin_options() const {
    return GetPointer<const void *>(VT_BUILTIN_OPTIONS);
  }
  template<typename T> const T *builtin_options_as() const;
  const Conv2DOptions *builtin_options_as_Conv2DOptions() const {
    return builtin_options_type() == BuiltinOptions_Conv2DOptions ? static_cast<const Conv2DOptions *>(builtin_options()) : nullptr;
  }
  const DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
    return builtin_options_type() == BuiltinOptions_DepthwiseConv2DOptions ? static_cast<const DepthwiseConv2DOptions *>(builtin_options()) : nullptr;
  }
  const ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
    return builtin_options_type() == BuiltinOptions_ConcatEmbeddingsOptions ? static_cast<const ConcatEmbeddingsOptions *>(builtin_options()) : nullptr;
  }
  const LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
    return builtin_options_type() == BuiltinOptions_LSHProjectionOptions ? static_cast<const LSHProjectionOptions *>(builtin_options()) : nullptr;
  }
  const Pool2DOptions *builtin_options_as_Pool2DOptions() const {
    return builtin_options_type() == BuiltinOptions_Pool2DOptions ? static_cast<const Pool2DOptions *>(builtin_options()) : nullptr;
  }
  const SVDFOptions *builtin_options_as_SVDFOptions() const {
    return builtin_options_type() == BuiltinOptions_SVDFOptions ? static_cast<const SVDFOptions *>(builtin_options()) : nullptr;
  }
  const RNNOptions *builtin_options_as_RNNOptions() const {
    return builtin_options_type() == BuiltinOptions_RNNOptions ? static_cast<const RNNOptions *>(builtin_options()) : nullptr;
  }
  const FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
    return builtin_options_type() == BuiltinOptions_FullyConnectedOptions ? static_cast<const FullyConnectedOptions *>(builtin_options()) : nullptr;
  }
  const SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
    return builtin_options_type() == BuiltinOptions_SoftmaxOptions ? static_cast<const SoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
    return builtin_options_type() == BuiltinOptions_ConcatenationOptions ? static_cast<const ConcatenationOptions *>(builtin_options()) : nullptr;
  }
  const AddOptions *builtin_options_as_AddOptions() const {
    return builtin_options_type() == BuiltinOptions_AddOptions ? static_cast<const AddOptions *>(builtin_options()) : nullptr;
  }
  const L2NormOptions *builtin_options_as_L2NormOptions() const {
    return builtin_options_type() == BuiltinOptions_L2NormOptions ? static_cast<const L2NormOptions *>(builtin_options()) : nullptr;
  }
  const LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
    return builtin_options_type() == BuiltinOptions_LocalResponseNormalizationOptions ? static_cast<const LocalResponseNormalizationOptions *>(builtin_options()) : nullptr;
  }
  const LSTMOptions *builtin_options_as_LSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_LSTMOptions ? static_cast<const LSTMOptions *>(builtin_options()) : nullptr;
  }
  const ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
    return builtin_options_type() == BuiltinOptions_ResizeBilinearOptions ? static_cast<const ResizeBilinearOptions *>(builtin_options()) : nullptr;
  }
  const CallOptions *builtin_options_as_CallOptions() const {
    return builtin_options_type() == BuiltinOptions_CallOptions ? static_cast<const CallOptions *>(builtin_options()) : nullptr;
  }
  const ReshapeOptions *builtin_options_as_ReshapeOptions() const {
    return builtin_options_type() == BuiltinOptions_ReshapeOptions ? static_cast<const ReshapeOptions *>(builtin_options()) : nullptr;
  }
  const SkipGramOptions *builtin_options_as_SkipGramOptions() const {
    return builtin_options_type() == BuiltinOptions_SkipGramOptions ? static_cast<const SkipGramOptions *>(builtin_options()) : nullptr;
  }
  const SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
    return builtin_options_type() == BuiltinOptions_SpaceToDepthOptions ? static_cast<const SpaceToDepthOptions *>(builtin_options()) : nullptr;
  }
  const EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
    return builtin_options_type() == BuiltinOptions_EmbeddingLookupSparseOptions ? static_cast<const EmbeddingLookupSparseOptions *>(builtin_options()) : nullptr;
  }
  const MulOptions *builtin_options_as_MulOptions() const {
    return builtin_options_type() == BuiltinOptions_MulOptions ? static_cast<const MulOptions *>(builtin_options()) : nullptr;
  }
  const PadOptions *builtin_options_as_PadOptions() const {
    return builtin_options_type() == BuiltinOptions_PadOptions ? static_cast<const PadOptions *>(builtin_options()) : nullptr;
  }
  const GatherOptions *builtin_options_as_GatherOptions() const {
    return builtin_options_type() == BuiltinOptions_GatherOptions ? static_cast<const GatherOptions *>(builtin_options()) : nullptr;
  }
  const BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
    return builtin_options_type() == BuiltinOptions_BatchToSpaceNDOptions ? static_cast<const BatchToSpaceNDOptions *>(builtin_options()) : nullptr;
  }
  const SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
    return builtin_options_type() == BuiltinOptions_SpaceToBatchNDOptions ? static_cast<const SpaceToBatchNDOptions *>(builtin_options()) : nullptr;
  }
  const TransposeOptions *builtin_options_as_TransposeOptions() const {
    return builtin_options_type() == BuiltinOptions_TransposeOptions ? static_cast<const TransposeOptions *>(builtin_options()) : nullptr;
  }
  const ReducerOptions *builtin_options_as_ReducerOptions() const {
    return builtin_options_type() == BuiltinOptions_ReducerOptions ? static_cast<const ReducerOptions *>(builtin_options()) : nullptr;
  }
  const SubOptions *builtin_options_as_SubOptions() const {
    return builtin_options_type() == BuiltinOptions_SubOptions ? static_cast<const SubOptions *>(builtin_options()) : nullptr;
  }
  const DivOptions *builtin_options_as_DivOptions() const {
    return builtin_options_type() == BuiltinOptions_DivOptions ? static_cast<const DivOptions *>(builtin_options()) : nullptr;
  }
  const SqueezeOptions *builtin_options_as_SqueezeOptions() const {
    return builtin_options_type() == BuiltinOptions_SqueezeOptions ? static_cast<const SqueezeOptions *>(builtin_options()) : nullptr;
  }
  const SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
    return builtin_options_type() == BuiltinOptions_SequenceRNNOptions ? static_cast<const SequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
    return builtin_options_type() == BuiltinOptions_StridedSliceOptions ? static_cast<const StridedSliceOptions *>(builtin_options()) : nullptr;
  }
  const ExpOptions *builtin_options_as_ExpOptions() const {
    return builtin_options_type() == BuiltinOptions_ExpOptions ? static_cast<const ExpOptions *>(builtin_options()) : nullptr;
  }
  const TopKV2Options *builtin_options_as_TopKV2Options() const {
    return builtin_options_type() == BuiltinOptions_TopKV2Options ? static_cast<const TopKV2Options *>(builtin_options()) : nullptr;
  }
  const SplitOptions *builtin_options_as_SplitOptions() const {
    return builtin_options_type() == BuiltinOptions_SplitOptions ? static_cast<const SplitOptions *>(builtin_options()) : nullptr;
  }
  const LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
    return builtin_options_type() == BuiltinOptions_LogSoftmaxOptions ? static_cast<const LogSoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const CastOptions *builtin_options_as_CastOptions() const {
    return builtin_options_type() == BuiltinOptions_CastOptions ? static_cast<const CastOptions *>(builtin_options()) : nullptr;
  }
  const DequantizeOptions *builtin_options_as_DequantizeOptions() const {
    return builtin_options_type() == BuiltinOptions_DequantizeOptions ? static_cast<const DequantizeOptions *>(builtin_options()) : nullptr;
  }
  const MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
    return builtin_options_type() == BuiltinOptions_MaximumMinimumOptions ? static_cast<const MaximumMinimumOptions *>(builtin_options()) : nullptr;
  }
  const ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
    return builtin_options_type() == BuiltinOptions_ArgMaxOptions ? static_cast<const ArgMaxOptions *>(builtin_options()) : nullptr;
  }
  const LessOptions *builtin_options_as_LessOptions() const {
    return builtin_options_type() == BuiltinOptions_LessOptions ? static_cast<const LessOptions *>(builtin_options()) : nullptr;
  }
  const NegOptions *builtin_options_as_NegOptions() const {
    return builtin_options_type() == BuiltinOptions_NegOptions ? static_cast<const NegOptions *>(builtin_options()) : nullptr;
  }
  const PadV2Options *builtin_options_as_PadV2Options() const {
    return builtin_options_type() == BuiltinOptions_PadV2Options ? static_cast<const PadV2Options *>(builtin_options()) : nullptr;
  }
  const GreaterOptions *builtin_options_as_GreaterOptions() const {
    return builtin_options_type() == BuiltinOptions_GreaterOptions ? static_cast<const GreaterOptions *>(builtin_options()) : nullptr;
  }
  const GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_GreaterEqualOptions ? static_cast<const GreaterEqualOptions *>(builtin_options()) : nullptr;
  }
  const LessEqualOptions *builtin_options_as_LessEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_LessEqualOptions ? static_cast<const LessEqualOptions *>(builtin_options()) : nullptr;
  }
  const SelectOptions *builtin_options_as_SelectOptions() const {
    return builtin_options_type() == BuiltinOptions_SelectOptions ? static_cast<const SelectOptions *>(builtin_options()) : nullptr;
  }
  const SliceOptions *builtin_options_as_SliceOptions() const {
    return builtin_options_type() == BuiltinOptions_SliceOptions ? static_cast<const SliceOptions *>(builtin_options()) : nullptr;
  }
  const TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
    return builtin_options_type() == BuiltinOptions_TransposeConvOptions ? static_cast<const TransposeConvOptions *>(builtin_options()) : nullptr;
  }
  const SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
    return builtin_options_type() == BuiltinOptions_SparseToDenseOptions ? static_cast<const SparseToDenseOptions *>(builtin_options()) : nullptr;
  }
  const TileOptions *builtin_options_as_TileOptions() const {
    return builtin_options_type() == BuiltinOptions_TileOptions ? static_cast<const TileOptions *>(builtin_options()) : nullptr;
  }
  const ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
    return builtin_options_type() == BuiltinOptions_ExpandDimsOptions ? static_cast<const ExpandDimsOptions *>(builtin_options()) : nullptr;
  }
  const EqualOptions *builtin_options_as_EqualOptions() const {
    return builtin_options_type() == BuiltinOptions_EqualOptions ? static_cast<const EqualOptions *>(builtin_options()) : nullptr;
  }
  const NotEqualOptions *builtin_options_as_NotEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_NotEqualOptions ? static_cast<const NotEqualOptions *>(builtin_options()) : nullptr;
  }
  const ShapeOptions *builtin_options_as_ShapeOptions() const {
    return builtin_options_type() == BuiltinOptions_ShapeOptions ? static_cast<const ShapeOptions *>(builtin_options()) : nullptr;
  }
  const PowOptions *builtin_options_as_PowOptions() const {
    return builtin_options_type() == BuiltinOptions_PowOptions ? static_cast<const PowOptions *>(builtin_options()) : nullptr;
  }
  const ArgMinOptions *builtin_options_as_ArgMinOptions() const {
    return builtin_options_type() == BuiltinOptions_ArgMinOptions ? static_cast<const ArgMinOptions *>(builtin_options()) : nullptr;
  }
  const FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
    return builtin_options_type() == BuiltinOptions_FakeQuantOptions ? static_cast<const FakeQuantOptions *>(builtin_options()) : nullptr;
  }
  const PackOptions *builtin_options_as_PackOptions() const {
    return builtin_options_type() == BuiltinOptions_PackOptions ? static_cast<const PackOptions *>(builtin_options()) : nullptr;
  }
  const LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalOrOptions ? static_cast<const LogicalOrOptions *>(builtin_options()) : nullptr;
  }
  const OneHotOptions *builtin_options_as_OneHotOptions() const {
    return builtin_options_type() == BuiltinOptions_OneHotOptions ? static_cast<const OneHotOptions *>(builtin_options()) : nullptr;
  }
  const LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalAndOptions ? static_cast<const LogicalAndOptions *>(builtin_options()) : nullptr;
  }
  const LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalNotOptions ? static_cast<const LogicalNotOptions *>(builtin_options()) : nullptr;
  }
  const UnpackOptions *builtin_options_as_UnpackOptions() const {
    return builtin_options_type() == BuiltinOptions_UnpackOptions ? static_cast<const UnpackOptions *>(builtin_options()) : nullptr;
  }
  const FloorDivOptions *builtin_options_as_FloorDivOptions() const {
    return builtin_options_type() == BuiltinOptions_FloorDivOptions ? static_cast<const FloorDivOptions *>(builtin_options()) : nullptr;
  }
  const SquareOptions *builtin_options_as_SquareOptions() const {
    return builtin_options_type() == BuiltinOptions_SquareOptions ? static_cast<const SquareOptions *>(builtin_options()) : nullptr;
  }
  const ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
    return builtin_options_type() == BuiltinOptions_ZerosLikeOptions ? static_cast<const ZerosLikeOptions *>(builtin_options()) : nullptr;
  }
  const FillOptions *builtin_options_as_FillOptions() const {
    return builtin_options_type() == BuiltinOptions_FillOptions ? static_cast<const FillOptions *>(builtin_options()) : nullptr;
  }
  const BidirectionalSequenceLSTMOptions *builtin_options_as_BidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_BidirectionalSequenceLSTMOptions ? static_cast<const BidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const BidirectionalSequenceRNNOptions *builtin_options_as_BidirectionalSequenceRNNOptions() const {
    return builtin_options_type() == BuiltinOptions_BidirectionalSequenceRNNOptions ? static_cast<const BidirectionalSequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const UnidirectionalSequenceLSTMOptions *builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_UnidirectionalSequenceLSTMOptions ? static_cast<const UnidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const FloorModOptions *builtin_options_as_FloorModOptions() const {
    return builtin_options_type() == BuiltinOptions_FloorModOptions ? static_cast<const FloorModOptions *>(builtin_options()) : nullptr;
  }
  const RangeOptions *builtin_options_as_RangeOptions() const {
    return builtin_options_type() == BuiltinOptions_RangeOptions ? static_cast<const RangeOptions *>(builtin_options()) : nullptr;
  }
  const ResizeNearestNeighborOptions *builtin_options_as_ResizeNearestNeighborOptions() const {
    return builtin_options_type() == BuiltinOptions_ResizeNearestNeighborOptions ? static_cast<const ResizeNearestNeighborOptions *>(builtin_options()) : nullptr;
  }
  const LeakyReluOptions *builtin_options_as_LeakyReluOptions() const {
    return builtin_options_type() == BuiltinOptions_LeakyReluOptions ? static_cast<const LeakyReluOptions *>(builtin_options()) : nullptr;
  }
  const SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const {
    return builtin_options_type() == BuiltinOptions_SquaredDifferenceOptions ? static_cast<const SquaredDifferenceOptions *>(builtin_options()) : nullptr;
  }
  const MirrorPadOptions *builtin_options_as_MirrorPadOptions() const {
    return builtin_options_type() == BuiltinOptions_MirrorPadOptions ? static_cast<const MirrorPadOptions *>(builtin_options()) : nullptr;
  }
  const AbsOptions *builtin_options_as_AbsOptions() const {
    return builtin_options_type() == BuiltinOptions_AbsOptions ? static_cast<const AbsOptions *>(builtin_options()) : nullptr;
  }
  const SplitVOptions *builtin_options_as_SplitVOptions() const {
    return builtin_options_type() == BuiltinOptions_SplitVOptions ? static_cast<const SplitVOptions *>(builtin_options()) : nullptr;
  }
  const UniqueOptions *builtin_options_as_UniqueOptions() const {
    return builtin_options_type() == BuiltinOptions_UniqueOptions ? static_cast<const UniqueOptions *>(builtin_options()) : nullptr;
  }
  const ReverseV2Options *builtin_options_as_ReverseV2Options() const {
    return builtin_options_type() == BuiltinOptions_ReverseV2Options ? static_cast<const ReverseV2Options *>(builtin_options()) : nullptr;
  }
  const AddNOptions *builtin_options_as_AddNOptions() const {
    return builtin_options_type() == BuiltinOptions_AddNOptions ? static_cast<const AddNOptions *>(builtin_options()) : nullptr;
  }
  const GatherNdOptions *builtin_options_as_GatherNdOptions() const {
    return builtin_options_type() == BuiltinOptions_GatherNdOptions ? static_cast<const GatherNdOptions *>(builtin_options()) : nullptr;
  }
  const CosOptions *builtin_options_as_CosOptions() const {
    return builtin_options_type() == BuiltinOptions_CosOptions ? static_cast<const CosOptions *>(builtin_options()) : nullptr;
  }
  const WhereOptions *builtin_options_as_WhereOptions() const {
    return builtin_options_type() == BuiltinOptions_WhereOptions ? static_cast<const WhereOptions *>(builtin_options()) : nullptr;
  }
  const RankOptions *builtin_options_as_RankOptions() const {
    return builtin_options_type() == BuiltinOptions_RankOptions ? static_cast<const RankOptions *>(builtin_options()) : nullptr;
  }
  const ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const {
    return builtin_options_type() == BuiltinOptions_ReverseSequenceOptions ? static_cast<const ReverseSequenceOptions *>(builtin_options()) : nullptr;
  }
  const MatrixDiagOptions *builtin_options_as_MatrixDiagOptions() const {
    return builtin_options_type() == BuiltinOptions_MatrixDiagOptions ? static_cast<const MatrixDiagOptions *>(builtin_options()) : nullptr;
  }
  const QuantizeOptions *builtin_options_as_QuantizeOptions() const {
    return builtin_options_type() == BuiltinOptions_QuantizeOptions ? static_cast<const QuantizeOptions *>(builtin_options()) : nullptr;
  }
  const MatrixSetDiagOptions *builtin_options_as_MatrixSetDiagOptions() const {
    return builtin_options_type() == BuiltinOptions_MatrixSetDiagOptions ? static_cast<const MatrixSetDiagOptions *>(builtin_options()) : nullptr;
  }
  const HardSwishOptions *builtin_options_as_HardSwishOptions() const {
    return builtin_options_type() == BuiltinOptions_HardSwishOptions ? static_cast<const HardSwishOptions *>(builtin_options()) : nullptr;
  }
  const IfOptions *builtin_options_as_IfOptions() const {
    return builtin_options_type() == BuiltinOptions_IfOptions ? static_cast<const IfOptions *>(builtin_options()) : nullptr;
  }
  const WhileOptions *builtin_options_as_WhileOptions() const {
    return builtin_options_type() == BuiltinOptions_WhileOptions ? static_cast<const WhileOptions *>(builtin_options()) : nullptr;
  }
  const DepthToSpaceOptions *builtin_options_as_DepthToSpaceOptions() const {
    return builtin_options_type() == BuiltinOptions_DepthToSpaceOptions ? static_cast<const DepthToSpaceOptions *>(builtin_options()) : nullptr;
  }
  const NonMaxSuppressionV4Options *builtin_options_as_NonMaxSuppressionV4Options() const {
    return builtin_options_type() == BuiltinOptions_NonMaxSuppressionV4Options ? static_cast<const NonMaxSuppressionV4Options *>(builtin_options()) : nullptr;
  }
  const NonMaxSuppressionV5Options *builtin_options_as_NonMaxSuppressionV5Options() const {
    return builtin_options_type() == BuiltinOptions_NonMaxSuppressionV5Options ? static_cast<const NonMaxSuppressionV5Options *>(builtin_options()) : nullptr;
  }
  const ScatterNdOptions *builtin_options_as_ScatterNdOptions() const {
    return builtin_options_type() == BuiltinOptions_ScatterNdOptions ? static_cast<const ScatterNdOptions *>(builtin_options()) : nullptr;
  }
  const SelectV2Options *builtin_options_as_SelectV2Options() const {
    return builtin_options_type() == BuiltinOptions_SelectV2Options ? static_cast<const SelectV2Options *>(builtin_options()) : nullptr;
  }
  const DensifyOptions *builtin_options_as_DensifyOptions() const {
    return builtin_options_type() == BuiltinOptions_DensifyOptions ? static_cast<const DensifyOptions *>(builtin_options()) : nullptr;
  }
  const SegmentSumOptions *builtin_options_as_SegmentSumOptions() const {
    return builtin_options_type() == BuiltinOptions_SegmentSumOptions ? static_cast<const SegmentSumOptions *>(builtin_options()) : nullptr;
  }
  const BatchMatMulOptions *builtin_options_as_BatchMatMulOptions() const {
    return builtin_options_type() == BuiltinOptions_BatchMatMulOptions ? static_cast<const BatchMatMulOptions *>(builtin_options()) : nullptr;
  }
  const CumsumOptions *builtin_options_as_CumsumOptions() const {
    return builtin_options_type() == BuiltinOptions_CumsumOptions ? static_cast<const CumsumOptions *>(builtin_options()) : nullptr;
  }
  const CallOnceOptions *builtin_options_as_CallOnceOptions() const {
    return builtin_options_type() == BuiltinOptions_CallOnceOptions ? static_cast<const CallOnceOptions *>(builtin_options()) : nullptr;
  }
  const BroadcastToOptions *builtin_options_as_BroadcastToOptions() const {
    return builtin_options_type() == BuiltinOptions_BroadcastToOptions ? static_cast<const BroadcastToOptions *>(builtin_options()) : nullptr;
  }
  const Rfft2dOptions *builtin_options_as_Rfft2dOptions() const {
    return builtin_options_type() == BuiltinOptions_Rfft2dOptions ? static_cast<const Rfft2dOptions *>(builtin_options()) : nullptr;
  }
  const Conv3DOptions *builtin_options_as_Conv3DOptions() const {
    return builtin_options_type() == BuiltinOptions_Conv3DOptions ? static_cast<const Conv3DOptions *>(builtin_options()) : nullptr;
  }
  const HashtableOptions *builtin_options_as_HashtableOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableOptions ? static_cast<const HashtableOptions *>(builtin_options()) : nullptr;
  }
  const HashtableFindOptions *builtin_options_as_HashtableFindOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableFindOptions ? static_cast<const HashtableFindOptions *>(builtin_options()) : nullptr;
  }
  const HashtableImportOptions *builtin_options_as_HashtableImportOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableImportOptions ? static_cast<const HashtableImportOptions *>(builtin_options()) : nullptr;
  }
  const HashtableSizeOptions *builtin_options_as_HashtableSizeOptions() const {
    return builtin_options_type() == BuiltinOptions_HashtableSizeOptions ? static_cast<const HashtableSizeOptions *>(builtin_options()) : nullptr;
  }
  const ENN_FlattenOptions *builtin_options_as_ENN_FlattenOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_FlattenOptions ? static_cast<const ENN_FlattenOptions *>(builtin_options()) : nullptr;
  }
  const ENN_CropOptions *builtin_options_as_ENN_CropOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_CropOptions ? static_cast<const ENN_CropOptions *>(builtin_options()) : nullptr;
  }
  const ENN_PermuteOptions *builtin_options_as_ENN_PermuteOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_PermuteOptions ? static_cast<const ENN_PermuteOptions *>(builtin_options()) : nullptr;
  }
  const ENN_PriorBoxOptions *builtin_options_as_ENN_PriorBoxOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_PriorBoxOptions ? static_cast<const ENN_PriorBoxOptions *>(builtin_options()) : nullptr;
  }
  const ENN_DetectionOptions *builtin_options_as_ENN_DetectionOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_DetectionOptions ? static_cast<const ENN_DetectionOptions *>(builtin_options()) : nullptr;
  }
  const ENN_PowerOptions *builtin_options_as_ENN_PowerOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_PowerOptions ? static_cast<const ENN_PowerOptions *>(builtin_options()) : nullptr;
  }
  const ENN_ScaleOptions *builtin_options_as_ENN_ScaleOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_ScaleOptions ? static_cast<const ENN_ScaleOptions *>(builtin_options()) : nullptr;
  }
  const ENN_TFliteDetectionOptions *builtin_options_as_ENN_TFliteDetectionOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_TFliteDetectionOptions ? static_cast<const ENN_TFliteDetectionOptions *>(builtin_options()) : nullptr;
  }
  const ENN_MeanOptions *builtin_options_as_ENN_MeanOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_MeanOptions ? static_cast<const ENN_MeanOptions *>(builtin_options()) : nullptr;
  }
  const ENN_TFliteSliceOptions *builtin_options_as_ENN_TFliteSliceOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_TFliteSliceOptions ? static_cast<const ENN_TFliteSliceOptions *>(builtin_options()) : nullptr;
  }
  const ENN_ReluOptions *builtin_options_as_ENN_ReluOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_ReluOptions ? static_cast<const ENN_ReluOptions *>(builtin_options()) : nullptr;
  }
  const ENN_EluOptions *builtin_options_as_ENN_EluOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_EluOptions ? static_cast<const ENN_EluOptions *>(builtin_options()) : nullptr;
  }
  const ENN_ClipOptions *builtin_options_as_ENN_ClipOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_ClipOptions ? static_cast<const ENN_ClipOptions *>(builtin_options()) : nullptr;
  }
  const ENN_CFUOptions *builtin_options_as_ENN_CFUOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_CFUOptions ? static_cast<const ENN_CFUOptions *>(builtin_options()) : nullptr;
  }
  const ENN_InverseCFUOptions *builtin_options_as_ENN_InverseCFUOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_InverseCFUOptions ? static_cast<const ENN_InverseCFUOptions *>(builtin_options()) : nullptr;
  }
  const ENN_NormalizationOptions *builtin_options_as_ENN_NormalizationOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_NormalizationOptions ? static_cast<const ENN_NormalizationOptions *>(builtin_options()) : nullptr;
  }
  const ENN_NPUOptions *builtin_options_as_ENN_NPUOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_NPUOptions ? static_cast<const ENN_NPUOptions *>(builtin_options()) : nullptr;
  }
  const ENN_DSPOptions *builtin_options_as_ENN_DSPOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_DSPOptions ? static_cast<const ENN_DSPOptions *>(builtin_options()) : nullptr;
  }
  const ENN_UNIFIED_DEVICEOptions *builtin_options_as_ENN_UNIFIED_DEVICEOptions() const {
    return builtin_options_type() == BuiltinOptions_ENN_UNIFIED_DEVICEOptions ? static_cast<const ENN_UNIFIED_DEVICEOptions *>(builtin_options()) : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *custom_options() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  CustomOptionsFormat custom_options_format() const {
    return static_cast<CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *intermediates() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTERMEDIATES);
  }
  TargetHw target_hw() const {
    return static_cast<TargetHw>(GetField<int8_t>(VT_TARGET_HW, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) &&
           verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           VerifyOffset(verifier, VT_INTERMEDIATES) &&
           verifier.VerifyVector(intermediates()) &&
           VerifyField<int8_t>(verifier, VT_TARGET_HW) &&
           verifier.EndTable();
  }
};

template<> inline const Conv2DOptions *Operator::builtin_options_as<Conv2DOptions>() const {
  return builtin_options_as_Conv2DOptions();
}

template<> inline const DepthwiseConv2DOptions *Operator::builtin_options_as<DepthwiseConv2DOptions>() const {
  return builtin_options_as_DepthwiseConv2DOptions();
}

template<> inline const ConcatEmbeddingsOptions *Operator::builtin_options_as<ConcatEmbeddingsOptions>() const {
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template<> inline const LSHProjectionOptions *Operator::builtin_options_as<LSHProjectionOptions>() const {
  return builtin_options_as_LSHProjectionOptions();
}

template<> inline const Pool2DOptions *Operator::builtin_options_as<Pool2DOptions>() const {
  return builtin_options_as_Pool2DOptions();
}

template<> inline const SVDFOptions *Operator::builtin_options_as<SVDFOptions>() const {
  return builtin_options_as_SVDFOptions();
}

template<> inline const RNNOptions *Operator::builtin_options_as<RNNOptions>() const {
  return builtin_options_as_RNNOptions();
}

template<> inline const FullyConnectedOptions *Operator::builtin_options_as<FullyConnectedOptions>() const {
  return builtin_options_as_FullyConnectedOptions();
}

template<> inline const SoftmaxOptions *Operator::builtin_options_as<SoftmaxOptions>() const {
  return builtin_options_as_SoftmaxOptions();
}

template<> inline const ConcatenationOptions *Operator::builtin_options_as<ConcatenationOptions>() const {
  return builtin_options_as_ConcatenationOptions();
}

template<> inline const AddOptions *Operator::builtin_options_as<AddOptions>() const {
  return builtin_options_as_AddOptions();
}

template<> inline const L2NormOptions *Operator::builtin_options_as<L2NormOptions>() const {
  return builtin_options_as_L2NormOptions();
}

template<> inline const LocalResponseNormalizationOptions *Operator::builtin_options_as<LocalResponseNormalizationOptions>() const {
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template<> inline const LSTMOptions *Operator::builtin_options_as<LSTMOptions>() const {
  return builtin_options_as_LSTMOptions();
}

template<> inline const ResizeBilinearOptions *Operator::builtin_options_as<ResizeBilinearOptions>() const {
  return builtin_options_as_ResizeBilinearOptions();
}

template<> inline const CallOptions *Operator::builtin_options_as<CallOptions>() const {
  return builtin_options_as_CallOptions();
}

template<> inline const ReshapeOptions *Operator::builtin_options_as<ReshapeOptions>() const {
  return builtin_options_as_ReshapeOptions();
}

template<> inline const SkipGramOptions *Operator::builtin_options_as<SkipGramOptions>() const {
  return builtin_options_as_SkipGramOptions();
}

template<> inline const SpaceToDepthOptions *Operator::builtin_options_as<SpaceToDepthOptions>() const {
  return builtin_options_as_SpaceToDepthOptions();
}

template<> inline const EmbeddingLookupSparseOptions *Operator::builtin_options_as<EmbeddingLookupSparseOptions>() const {
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template<> inline const MulOptions *Operator::builtin_options_as<MulOptions>() const {
  return builtin_options_as_MulOptions();
}

template<> inline const PadOptions *Operator::builtin_options_as<PadOptions>() const {
  return builtin_options_as_PadOptions();
}

template<> inline const GatherOptions *Operator::builtin_options_as<GatherOptions>() const {
  return builtin_options_as_GatherOptions();
}

template<> inline const BatchToSpaceNDOptions *Operator::builtin_options_as<BatchToSpaceNDOptions>() const {
  return builtin_options_as_BatchToSpaceNDOptions();
}

template<> inline const SpaceToBatchNDOptions *Operator::builtin_options_as<SpaceToBatchNDOptions>() const {
  return builtin_options_as_SpaceToBatchNDOptions();
}

template<> inline const TransposeOptions *Operator::builtin_options_as<TransposeOptions>() const {
  return builtin_options_as_TransposeOptions();
}

template<> inline const ReducerOptions *Operator::builtin_options_as<ReducerOptions>() const {
  return builtin_options_as_ReducerOptions();
}

template<> inline const SubOptions *Operator::builtin_options_as<SubOptions>() const {
  return builtin_options_as_SubOptions();
}

template<> inline const DivOptions *Operator::builtin_options_as<DivOptions>() const {
  return builtin_options_as_DivOptions();
}

template<> inline const SqueezeOptions *Operator::builtin_options_as<SqueezeOptions>() const {
  return builtin_options_as_SqueezeOptions();
}

template<> inline const SequenceRNNOptions *Operator::builtin_options_as<SequenceRNNOptions>() const {
  return builtin_options_as_SequenceRNNOptions();
}

template<> inline const StridedSliceOptions *Operator::builtin_options_as<StridedSliceOptions>() const {
  return builtin_options_as_StridedSliceOptions();
}

template<> inline const ExpOptions *Operator::builtin_options_as<ExpOptions>() const {
  return builtin_options_as_ExpOptions();
}

template<> inline const TopKV2Options *Operator::builtin_options_as<TopKV2Options>() const {
  return builtin_options_as_TopKV2Options();
}

template<> inline const SplitOptions *Operator::builtin_options_as<SplitOptions>() const {
  return builtin_options_as_SplitOptions();
}

template<> inline const LogSoftmaxOptions *Operator::builtin_options_as<LogSoftmaxOptions>() const {
  return builtin_options_as_LogSoftmaxOptions();
}

template<> inline const CastOptions *Operator::builtin_options_as<CastOptions>() const {
  return builtin_options_as_CastOptions();
}

template<> inline const DequantizeOptions *Operator::builtin_options_as<DequantizeOptions>() const {
  return builtin_options_as_DequantizeOptions();
}

template<> inline const MaximumMinimumOptions *Operator::builtin_options_as<MaximumMinimumOptions>() const {
  return builtin_options_as_MaximumMinimumOptions();
}

template<> inline const ArgMaxOptions *Operator::builtin_options_as<ArgMaxOptions>() const {
  return builtin_options_as_ArgMaxOptions();
}

template<> inline const LessOptions *Operator::builtin_options_as<LessOptions>() const {
  return builtin_options_as_LessOptions();
}

template<> inline const NegOptions *Operator::builtin_options_as<NegOptions>() const {
  return builtin_options_as_NegOptions();
}

template<> inline const PadV2Options *Operator::builtin_options_as<PadV2Options>() const {
  return builtin_options_as_PadV2Options();
}

template<> inline const GreaterOptions *Operator::builtin_options_as<GreaterOptions>() const {
  return builtin_options_as_GreaterOptions();
}

template<> inline const GreaterEqualOptions *Operator::builtin_options_as<GreaterEqualOptions>() const {
  return builtin_options_as_GreaterEqualOptions();
}

template<> inline const LessEqualOptions *Operator::builtin_options_as<LessEqualOptions>() const {
  return builtin_options_as_LessEqualOptions();
}

template<> inline const SelectOptions *Operator::builtin_options_as<SelectOptions>() const {
  return builtin_options_as_SelectOptions();
}

template<> inline const SliceOptions *Operator::builtin_options_as<SliceOptions>() const {
  return builtin_options_as_SliceOptions();
}

template<> inline const TransposeConvOptions *Operator::builtin_options_as<TransposeConvOptions>() const {
  return builtin_options_as_TransposeConvOptions();
}

template<> inline const SparseToDenseOptions *Operator::builtin_options_as<SparseToDenseOptions>() const {
  return builtin_options_as_SparseToDenseOptions();
}

template<> inline const TileOptions *Operator::builtin_options_as<TileOptions>() const {
  return builtin_options_as_TileOptions();
}

template<> inline const ExpandDimsOptions *Operator::builtin_options_as<ExpandDimsOptions>() const {
  return builtin_options_as_ExpandDimsOptions();
}

template<> inline const EqualOptions *Operator::builtin_options_as<EqualOptions>() const {
  return builtin_options_as_EqualOptions();
}

template<> inline const NotEqualOptions *Operator::builtin_options_as<NotEqualOptions>() const {
  return builtin_options_as_NotEqualOptions();
}

template<> inline const ShapeOptions *Operator::builtin_options_as<ShapeOptions>() const {
  return builtin_options_as_ShapeOptions();
}

template<> inline const PowOptions *Operator::builtin_options_as<PowOptions>() const {
  return builtin_options_as_PowOptions();
}

template<> inline const ArgMinOptions *Operator::builtin_options_as<ArgMinOptions>() const {
  return builtin_options_as_ArgMinOptions();
}

template<> inline const FakeQuantOptions *Operator::builtin_options_as<FakeQuantOptions>() const {
  return builtin_options_as_FakeQuantOptions();
}

template<> inline const PackOptions *Operator::builtin_options_as<PackOptions>() const {
  return builtin_options_as_PackOptions();
}

template<> inline const LogicalOrOptions *Operator::builtin_options_as<LogicalOrOptions>() const {
  return builtin_options_as_LogicalOrOptions();
}

template<> inline const OneHotOptions *Operator::builtin_options_as<OneHotOptions>() const {
  return builtin_options_as_OneHotOptions();
}

template<> inline const LogicalAndOptions *Operator::builtin_options_as<LogicalAndOptions>() const {
  return builtin_options_as_LogicalAndOptions();
}

template<> inline const LogicalNotOptions *Operator::builtin_options_as<LogicalNotOptions>() const {
  return builtin_options_as_LogicalNotOptions();
}

template<> inline const UnpackOptions *Operator::builtin_options_as<UnpackOptions>() const {
  return builtin_options_as_UnpackOptions();
}

template<> inline const FloorDivOptions *Operator::builtin_options_as<FloorDivOptions>() const {
  return builtin_options_as_FloorDivOptions();
}

template<> inline const SquareOptions *Operator::builtin_options_as<SquareOptions>() const {
  return builtin_options_as_SquareOptions();
}

template<> inline const ZerosLikeOptions *Operator::builtin_options_as<ZerosLikeOptions>() const {
  return builtin_options_as_ZerosLikeOptions();
}

template<> inline const FillOptions *Operator::builtin_options_as<FillOptions>() const {
  return builtin_options_as_FillOptions();
}

template<> inline const BidirectionalSequenceLSTMOptions *Operator::builtin_options_as<BidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template<> inline const BidirectionalSequenceRNNOptions *Operator::builtin_options_as<BidirectionalSequenceRNNOptions>() const {
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template<> inline const UnidirectionalSequenceLSTMOptions *Operator::builtin_options_as<UnidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template<> inline const FloorModOptions *Operator::builtin_options_as<FloorModOptions>() const {
  return builtin_options_as_FloorModOptions();
}

template<> inline const RangeOptions *Operator::builtin_options_as<RangeOptions>() const {
  return builtin_options_as_RangeOptions();
}

template<> inline const ResizeNearestNeighborOptions *Operator::builtin_options_as<ResizeNearestNeighborOptions>() const {
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template<> inline const LeakyReluOptions *Operator::builtin_options_as<LeakyReluOptions>() const {
  return builtin_options_as_LeakyReluOptions();
}

template<> inline const SquaredDifferenceOptions *Operator::builtin_options_as<SquaredDifferenceOptions>() const {
  return builtin_options_as_SquaredDifferenceOptions();
}

template<> inline const MirrorPadOptions *Operator::builtin_options_as<MirrorPadOptions>() const {
  return builtin_options_as_MirrorPadOptions();
}

template<> inline const AbsOptions *Operator::builtin_options_as<AbsOptions>() const {
  return builtin_options_as_AbsOptions();
}

template<> inline const SplitVOptions *Operator::builtin_options_as<SplitVOptions>() const {
  return builtin_options_as_SplitVOptions();
}

template<> inline const UniqueOptions *Operator::builtin_options_as<UniqueOptions>() const {
  return builtin_options_as_UniqueOptions();
}

template<> inline const ReverseV2Options *Operator::builtin_options_as<ReverseV2Options>() const {
  return builtin_options_as_ReverseV2Options();
}

template<> inline const AddNOptions *Operator::builtin_options_as<AddNOptions>() const {
  return builtin_options_as_AddNOptions();
}

template<> inline const GatherNdOptions *Operator::builtin_options_as<GatherNdOptions>() const {
  return builtin_options_as_GatherNdOptions();
}

template<> inline const CosOptions *Operator::builtin_options_as<CosOptions>() const {
  return builtin_options_as_CosOptions();
}

template<> inline const WhereOptions *Operator::builtin_options_as<WhereOptions>() const {
  return builtin_options_as_WhereOptions();
}

template<> inline const RankOptions *Operator::builtin_options_as<RankOptions>() const {
  return builtin_options_as_RankOptions();
}

template<> inline const ReverseSequenceOptions *Operator::builtin_options_as<ReverseSequenceOptions>() const {
  return builtin_options_as_ReverseSequenceOptions();
}

template<> inline const MatrixDiagOptions *Operator::builtin_options_as<MatrixDiagOptions>() const {
  return builtin_options_as_MatrixDiagOptions();
}

template<> inline const QuantizeOptions *Operator::builtin_options_as<QuantizeOptions>() const {
  return builtin_options_as_QuantizeOptions();
}

template<> inline const MatrixSetDiagOptions *Operator::builtin_options_as<MatrixSetDiagOptions>() const {
  return builtin_options_as_MatrixSetDiagOptions();
}

template<> inline const HardSwishOptions *Operator::builtin_options_as<HardSwishOptions>() const {
  return builtin_options_as_HardSwishOptions();
}

template<> inline const IfOptions *Operator::builtin_options_as<IfOptions>() const {
  return builtin_options_as_IfOptions();
}

template<> inline const WhileOptions *Operator::builtin_options_as<WhileOptions>() const {
  return builtin_options_as_WhileOptions();
}

template<> inline const DepthToSpaceOptions *Operator::builtin_options_as<DepthToSpaceOptions>() const {
  return builtin_options_as_DepthToSpaceOptions();
}

template<> inline const NonMaxSuppressionV4Options *Operator::builtin_options_as<NonMaxSuppressionV4Options>() const {
  return builtin_options_as_NonMaxSuppressionV4Options();
}

template<> inline const NonMaxSuppressionV5Options *Operator::builtin_options_as<NonMaxSuppressionV5Options>() const {
  return builtin_options_as_NonMaxSuppressionV5Options();
}

template<> inline const ScatterNdOptions *Operator::builtin_options_as<ScatterNdOptions>() const {
  return builtin_options_as_ScatterNdOptions();
}

template<> inline const SelectV2Options *Operator::builtin_options_as<SelectV2Options>() const {
  return builtin_options_as_SelectV2Options();
}

template<> inline const DensifyOptions *Operator::builtin_options_as<DensifyOptions>() const {
  return builtin_options_as_DensifyOptions();
}

template<> inline const SegmentSumOptions *Operator::builtin_options_as<SegmentSumOptions>() const {
  return builtin_options_as_SegmentSumOptions();
}

template<> inline const BatchMatMulOptions *Operator::builtin_options_as<BatchMatMulOptions>() const {
  return builtin_options_as_BatchMatMulOptions();
}

template<> inline const CumsumOptions *Operator::builtin_options_as<CumsumOptions>() const {
  return builtin_options_as_CumsumOptions();
}

template<> inline const CallOnceOptions *Operator::builtin_options_as<CallOnceOptions>() const {
  return builtin_options_as_CallOnceOptions();
}

template<> inline const BroadcastToOptions *Operator::builtin_options_as<BroadcastToOptions>() const {
  return builtin_options_as_BroadcastToOptions();
}

template<> inline const Rfft2dOptions *Operator::builtin_options_as<Rfft2dOptions>() const {
  return builtin_options_as_Rfft2dOptions();
}

template<> inline const Conv3DOptions *Operator::builtin_options_as<Conv3DOptions>() const {
  return builtin_options_as_Conv3DOptions();
}

template<> inline const HashtableOptions *Operator::builtin_options_as<HashtableOptions>() const {
  return builtin_options_as_HashtableOptions();
}

template<> inline const HashtableFindOptions *Operator::builtin_options_as<HashtableFindOptions>() const {
  return builtin_options_as_HashtableFindOptions();
}

template<> inline const HashtableImportOptions *Operator::builtin_options_as<HashtableImportOptions>() const {
  return builtin_options_as_HashtableImportOptions();
}

template<> inline const HashtableSizeOptions *Operator::builtin_options_as<HashtableSizeOptions>() const {
  return builtin_options_as_HashtableSizeOptions();
}

template<> inline const ENN_FlattenOptions *Operator::builtin_options_as<ENN_FlattenOptions>() const {
  return builtin_options_as_ENN_FlattenOptions();
}

template<> inline const ENN_CropOptions *Operator::builtin_options_as<ENN_CropOptions>() const {
  return builtin_options_as_ENN_CropOptions();
}

template<> inline const ENN_PermuteOptions *Operator::builtin_options_as<ENN_PermuteOptions>() const {
  return builtin_options_as_ENN_PermuteOptions();
}

template<> inline const ENN_PriorBoxOptions *Operator::builtin_options_as<ENN_PriorBoxOptions>() const {
  return builtin_options_as_ENN_PriorBoxOptions();
}

template<> inline const ENN_DetectionOptions *Operator::builtin_options_as<ENN_DetectionOptions>() const {
  return builtin_options_as_ENN_DetectionOptions();
}

template<> inline const ENN_PowerOptions *Operator::builtin_options_as<ENN_PowerOptions>() const {
  return builtin_options_as_ENN_PowerOptions();
}

template<> inline const ENN_ScaleOptions *Operator::builtin_options_as<ENN_ScaleOptions>() const {
  return builtin_options_as_ENN_ScaleOptions();
}

template<> inline const ENN_TFliteDetectionOptions *Operator::builtin_options_as<ENN_TFliteDetectionOptions>() const {
  return builtin_options_as_ENN_TFliteDetectionOptions();
}

template<> inline const ENN_MeanOptions *Operator::builtin_options_as<ENN_MeanOptions>() const {
  return builtin_options_as_ENN_MeanOptions();
}

template<> inline const ENN_TFliteSliceOptions *Operator::builtin_options_as<ENN_TFliteSliceOptions>() const {
  return builtin_options_as_ENN_TFliteSliceOptions();
}

template<> inline const ENN_ReluOptions *Operator::builtin_options_as<ENN_ReluOptions>() const {
  return builtin_options_as_ENN_ReluOptions();
}

template<> inline const ENN_EluOptions *Operator::builtin_options_as<ENN_EluOptions>() const {
  return builtin_options_as_ENN_EluOptions();
}

template<> inline const ENN_ClipOptions *Operator::builtin_options_as<ENN_ClipOptions>() const {
  return builtin_options_as_ENN_ClipOptions();
}

template<> inline const ENN_CFUOptions *Operator::builtin_options_as<ENN_CFUOptions>() const {
  return builtin_options_as_ENN_CFUOptions();
}

template<> inline const ENN_InverseCFUOptions *Operator::builtin_options_as<ENN_InverseCFUOptions>() const {
  return builtin_options_as_ENN_InverseCFUOptions();
}

template<> inline const ENN_NormalizationOptions *Operator::builtin_options_as<ENN_NormalizationOptions>() const {
  return builtin_options_as_ENN_NormalizationOptions();
}

template<> inline const ENN_NPUOptions *Operator::builtin_options_as<ENN_NPUOptions>() const {
  return builtin_options_as_ENN_NPUOptions();
}

template<> inline const ENN_DSPOptions *Operator::builtin_options_as<ENN_DSPOptions>() const {
  return builtin_options_as_ENN_DSPOptions();
}

template<> inline const ENN_UNIFIED_DEVICEOptions *Operator::builtin_options_as<ENN_UNIFIED_DEVICEOptions>() const {
  return builtin_options_as_ENN_UNIFIED_DEVICEOptions();
}

struct OperatorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index) {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(BuiltinOptions builtin_options_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(CustomOptionsFormat custom_options_format) {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  void add_intermediates(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates) {
    fbb_.AddOffset(Operator::VT_INTERMEDIATES, intermediates);
  }
  void add_target_hw(TargetHw target_hw) {
    fbb_.AddElement<int8_t>(Operator::VT_TARGET_HW, static_cast<int8_t>(target_hw), 0);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorBuilder &operator=(const OperatorBuilder &);
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    BuiltinOptions builtin_options_type = BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    CustomOptionsFormat custom_options_format = CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intermediates = 0,
    TargetHw target_hw = TargetHw_NONE) {
  OperatorBuilder builder_(_fbb);
  builder_.add_intermediates(intermediates);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_target_hw(target_hw);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    BuiltinOptions builtin_options_type = BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    const std::vector<uint8_t> *custom_options = nullptr,
    CustomOptionsFormat custom_options_format = CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t> *mutating_variable_inputs = nullptr,
    const std::vector<int32_t> *intermediates = nullptr,
    TargetHw target_hw = TargetHw_NONE) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto custom_options__ = custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0;
  auto mutating_variable_inputs__ = mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0;
  auto intermediates__ = intermediates ? _fbb.CreateVector<int32_t>(*intermediates) : 0;
  return tflite::v2::CreateOperator(
      _fbb,
      opcode_index,
      inputs__,
      outputs__,
      builtin_options_type,
      builtin_options,
      custom_options__,
      custom_options_format,
      mutating_variable_inputs__,
      intermediates__,
      target_hw);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Operator>> *operators() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Operator>> *>(VT_OPERATORS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SubGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Operator>>> operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphBuilder &operator=(const SubGraphBuilder &);
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<Operator>> *operators = nullptr,
    const char *name = nullptr) {
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<Tensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<Operator>>(*operators) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::v2::CreateSubGraph(
      _fbb,
      tensors__,
      inputs__,
      outputs__,
      operators__,
      name__);
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::v2::CreateBuffer(
      _fbb,
      data__);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_BUFFER = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Metadata::VT_NAME, name);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Metadata::VT_BUFFER, buffer, 0);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataBuilder &operator=(const MetadataBuilder &);
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t buffer = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t buffer = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::v2::CreateMetadata(
      _fbb,
      name__,
      buffer);
}

struct TensorMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TENSOR_INDEX = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t tensor_index() const {
    return GetField<uint32_t>(VT_TENSOR_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TENSOR_INDEX) &&
           verifier.EndTable();
  }
};

struct TensorMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorMap::VT_NAME, name);
  }
  void add_tensor_index(uint32_t tensor_index) {
    fbb_.AddElement<uint32_t>(TensorMap::VT_TENSOR_INDEX, tensor_index, 0);
  }
  explicit TensorMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorMapBuilder &operator=(const TensorMapBuilder &);
  flatbuffers::Offset<TensorMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorMap> CreateTensorMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t tensor_index = 0) {
  TensorMapBuilder builder_(_fbb);
  builder_.add_tensor_index(tensor_index);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorMap> CreateTensorMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t tensor_index = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::v2::CreateTensorMap(
      _fbb,
      name__,
      tensor_index);
}

struct SignatureDef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTS = 4,
    VT_OUTPUTS = 6,
    VT_METHOD_NAME = 8,
    VT_KEY = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorMap>> *>(VT_OUTPUTS);
  }
  const flatbuffers::String *method_name() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD_NAME);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           VerifyOffset(verifier, VT_METHOD_NAME) &&
           verifier.VerifyString(method_name()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct SignatureDefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> inputs) {
    fbb_.AddOffset(SignatureDef::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> outputs) {
    fbb_.AddOffset(SignatureDef::VT_OUTPUTS, outputs);
  }
  void add_method_name(flatbuffers::Offset<flatbuffers::String> method_name) {
    fbb_.AddOffset(SignatureDef::VT_METHOD_NAME, method_name);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(SignatureDef::VT_KEY, key);
  }
  explicit SignatureDefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignatureDefBuilder &operator=(const SignatureDefBuilder &);
  flatbuffers::Offset<SignatureDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignatureDef>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignatureDef> CreateSignatureDef(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorMap>>> outputs = 0,
    flatbuffers::Offset<flatbuffers::String> method_name = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0) {
  SignatureDefBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_method_name(method_name);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignatureDef> CreateSignatureDefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TensorMap>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<TensorMap>> *outputs = nullptr,
    const char *method_name = nullptr,
    const char *key = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<TensorMap>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<TensorMap>>(*outputs) : 0;
  auto method_name__ = method_name ? _fbb.CreateString(method_name) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return tflite::v2::CreateSignatureDef(
      _fbb,
      inputs__,
      outputs__,
      method_name__,
      key__);
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14,
    VT_METADATA = 16,
    VT_SIGNATURE_DEFS = 18,
    VT_COMPATIBLE = 20,
    VT_RELAXCOMPUTATIONFLOAT32TOFLOAT16 = 22
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OperatorCode>> *operator_codes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OperatorCode>> *>(VT_OPERATOR_CODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *>(VT_SUBGRAPHS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *>(VT_BUFFERS);
  }
  const flatbuffers::Vector<int32_t> *metadata_buffer() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Metadata>> *metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Metadata>> *>(VT_METADATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SignatureDef>> *signature_defs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SignatureDef>> *>(VT_SIGNATURE_DEFS);
  }
  const flatbuffers::Vector<int32_t> *compatible() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_COMPATIBLE);
  }
  bool relaxComputationFloat32toFloat16() const {
    return GetField<uint8_t>(VT_RELAXCOMPUTATIONFLOAT32TOFLOAT16, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) &&
           verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) &&
           verifier.VerifyVector(metadata_buffer()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           VerifyOffset(verifier, VT_SIGNATURE_DEFS) &&
           verifier.VerifyVector(signature_defs()) &&
           verifier.VerifyVectorOfTables(signature_defs()) &&
           VerifyOffset(verifier, VT_COMPATIBLE) &&
           verifier.VerifyVector(compatible()) &&
           VerifyField<uint8_t>(verifier, VT_RELAXCOMPUTATIONFLOAT32TOFLOAT16) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
  }
  void add_operator_codes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OperatorCode>>> operator_codes) {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subgraphs) {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers) {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  void add_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Metadata>>> metadata) {
    fbb_.AddOffset(Model::VT_METADATA, metadata);
  }
  void add_signature_defs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SignatureDef>>> signature_defs) {
    fbb_.AddOffset(Model::VT_SIGNATURE_DEFS, signature_defs);
  }
  void add_compatible(flatbuffers::Offset<flatbuffers::Vector<int32_t>> compatible) {
    fbb_.AddOffset(Model::VT_COMPATIBLE, compatible);
  }
  void add_relaxComputationFloat32toFloat16(bool relaxComputationFloat32toFloat16) {
    fbb_.AddElement<uint8_t>(Model::VT_RELAXCOMPUTATIONFLOAT32TOFLOAT16, static_cast<uint8_t>(relaxComputationFloat32toFloat16), 1);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OperatorCode>>> operator_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Metadata>>> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SignatureDef>>> signature_defs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> compatible = 0,
    bool relaxComputationFloat32toFloat16 = true) {
  ModelBuilder builder_(_fbb);
  builder_.add_compatible(compatible);
  builder_.add_signature_defs(signature_defs);
  builder_.add_metadata(metadata);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  builder_.add_relaxComputationFloat32toFloat16(relaxComputationFloat32toFloat16);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<flatbuffers::Offset<OperatorCode>> *operator_codes = nullptr,
    const std::vector<flatbuffers::Offset<SubGraph>> *subgraphs = nullptr,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<Buffer>> *buffers = nullptr,
    const std::vector<int32_t> *metadata_buffer = nullptr,
    const std::vector<flatbuffers::Offset<Metadata>> *metadata = nullptr,
    const std::vector<flatbuffers::Offset<SignatureDef>> *signature_defs = nullptr,
    const std::vector<int32_t> *compatible = nullptr,
    bool relaxComputationFloat32toFloat16 = true) {
  auto operator_codes__ = operator_codes ? _fbb.CreateVector<flatbuffers::Offset<OperatorCode>>(*operator_codes) : 0;
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<flatbuffers::Offset<SubGraph>>(*subgraphs) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<Buffer>>(*buffers) : 0;
  auto metadata_buffer__ = metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<flatbuffers::Offset<Metadata>>(*metadata) : 0;
  auto signature_defs__ = signature_defs ? _fbb.CreateVector<flatbuffers::Offset<SignatureDef>>(*signature_defs) : 0;
  auto compatible__ = compatible ? _fbb.CreateVector<int32_t>(*compatible) : 0;
  return tflite::v2::CreateModel(
      _fbb,
      version,
      operator_codes__,
      subgraphs__,
      description__,
      buffers__,
      metadata_buffer__,
      metadata__,
      signature_defs__,
      compatible__,
      relaxComputationFloat32toFloat16);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {
  switch (type) {
    case QuantizationDetails_NONE: {
      return true;
    }
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizationDetails(
        verifier,  values->Get(i), types->GetEnum<QuantizationDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifySparseIndexVector(flatbuffers::Verifier &verifier, const void *obj, SparseIndexVector type) {
  switch (type) {
    case SparseIndexVector_NONE: {
      return true;
    }
    case SparseIndexVector_Int32Vector: {
      auto ptr = reinterpret_cast<const Int32Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint16Vector: {
      auto ptr = reinterpret_cast<const Uint16Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SparseIndexVector_Uint8Vector: {
      auto ptr = reinterpret_cast<const Uint8Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifySparseIndexVectorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySparseIndexVector(
        verifier,  values->Get(i), types->GetEnum<SparseIndexVector>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
  switch (type) {
    case BuiltinOptions_NONE: {
      return true;
    }
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const UniqueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const ReverseV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const AddNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const GatherNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const CosOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const WhereOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const RankOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const ReverseSequenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_QuantizeOptions: {
      auto ptr = reinterpret_cast<const QuantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MatrixSetDiagOptions: {
      auto ptr = reinterpret_cast<const MatrixSetDiagOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HardSwishOptions: {
      auto ptr = reinterpret_cast<const HardSwishOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_IfOptions: {
      auto ptr = reinterpret_cast<const IfOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhileOptions: {
      auto ptr = reinterpret_cast<const WhileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthToSpaceOptions: {
      auto ptr = reinterpret_cast<const DepthToSpaceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV4Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV4Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NonMaxSuppressionV5Options: {
      auto ptr = reinterpret_cast<const NonMaxSuppressionV5Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ScatterNdOptions: {
      auto ptr = reinterpret_cast<const ScatterNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectV2Options: {
      auto ptr = reinterpret_cast<const SelectV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DensifyOptions: {
      auto ptr = reinterpret_cast<const DensifyOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SegmentSumOptions: {
      auto ptr = reinterpret_cast<const SegmentSumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchMatMulOptions: {
      auto ptr = reinterpret_cast<const BatchMatMulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CumsumOptions: {
      auto ptr = reinterpret_cast<const CumsumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOnceOptions: {
      auto ptr = reinterpret_cast<const CallOnceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BroadcastToOptions: {
      auto ptr = reinterpret_cast<const BroadcastToOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Rfft2dOptions: {
      auto ptr = reinterpret_cast<const Rfft2dOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Conv3DOptions: {
      auto ptr = reinterpret_cast<const Conv3DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableOptions: {
      auto ptr = reinterpret_cast<const HashtableOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableFindOptions: {
      auto ptr = reinterpret_cast<const HashtableFindOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableImportOptions: {
      auto ptr = reinterpret_cast<const HashtableImportOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_HashtableSizeOptions: {
      auto ptr = reinterpret_cast<const HashtableSizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_FlattenOptions: {
      auto ptr = reinterpret_cast<const ENN_FlattenOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_CropOptions: {
      auto ptr = reinterpret_cast<const ENN_CropOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_PermuteOptions: {
      auto ptr = reinterpret_cast<const ENN_PermuteOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_PriorBoxOptions: {
      auto ptr = reinterpret_cast<const ENN_PriorBoxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_DetectionOptions: {
      auto ptr = reinterpret_cast<const ENN_DetectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_PowerOptions: {
      auto ptr = reinterpret_cast<const ENN_PowerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_ScaleOptions: {
      auto ptr = reinterpret_cast<const ENN_ScaleOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_TFliteDetectionOptions: {
      auto ptr = reinterpret_cast<const ENN_TFliteDetectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_MeanOptions: {
      auto ptr = reinterpret_cast<const ENN_MeanOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_TFliteSliceOptions: {
      auto ptr = reinterpret_cast<const ENN_TFliteSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_ReluOptions: {
      auto ptr = reinterpret_cast<const ENN_ReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_EluOptions: {
      auto ptr = reinterpret_cast<const ENN_EluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_ClipOptions: {
      auto ptr = reinterpret_cast<const ENN_ClipOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_CFUOptions: {
      auto ptr = reinterpret_cast<const ENN_CFUOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_InverseCFUOptions: {
      auto ptr = reinterpret_cast<const ENN_InverseCFUOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_NormalizationOptions: {
      auto ptr = reinterpret_cast<const ENN_NormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_NPUOptions: {
      auto ptr = reinterpret_cast<const ENN_NPUOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_DSPOptions: {
      auto ptr = reinterpret_cast<const ENN_DSPOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ENN_UNIFIED_DEVICEOptions: {
      auto ptr = reinterpret_cast<const ENN_UNIFIED_DEVICEOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions(
        verifier,  values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline const tflite::v2::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<tflite::v2::Model>(buf);
}

inline const tflite::v2::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::v2::Model>(buf);
}

inline const char *ModelIdentifier() {
  return "ENNC";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::v2::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::v2::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
  return "nnc";
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::v2::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::v2::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

}  // namespace v2
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_V2_H_
