---
Title: Build
Output: pdf_document
author: Hoon Choi
Date: 2021. 02. 04
Reference: https://ogom.github.io/draw_uml/plantuml/
---

#### 1. Basic concept of medium interface
```plantUML
top to bottom direction

skinparam actorStyle awesome
skinparam DefaultTextAlignment center
skinparam arrowColor #000000
skinparam rectangleBackgroundColor #CFE2F3
skinparam storageBackgroundColor #E2C2F3
skinparam fileBackgroundColor #CFE2F3
skinparam databaseBackgroundColor #CFE2F3
skinparam defaultFontSize 15

frame "HIDL mode build" {
  cloud "RPC" as rpc
  storage "android hidl : IEnnInterface" as iif1
  interface "types.hal" as typeshal
  storage "android hidl : IEnnInterface" as iif2
}

rectangle "                  medium_interface                " as mi
rectangle "               engine              " as mic
frame "non-HIDL(lib) mode build" {
  label "( direct call )" as dc
  interface "types.hal.h" as typeshalh
}

mi --> iif1
iif1 ..> rpc
rpc - typeshal
rpc ..> iif2
iif2--> mic
mi -- dc
dc -left- typeshalh
dc -> mic

typeshal ...right...> typeshalh : generates
```

> 1. with lib mode build (build.sh with -l option), build script hide all of HIDL related libraries in Android. Therefore, if user calls a member function of medium_interface, member function of medium_interface_core is called.
> 2. with hidl mode build, medium interface invokes a function of the same name in IEnnInterface and it calls automatically calls that function of IEnnInterface in Service process. (we generally call it Remote Procedure Call)
> 3. The parameter of HIDL is generated by types.hal. In lib mode, make_hal_to_header.sh is automatically called by build shell script, and it tries to generate types.hal.h from types.hal.
> 4. Currently the build shell script generates both lib and hidl mode executable and libraries. (2021.07 ~)

<br><br>
### 2. Case review: Basic flow of enn_initialize()
#### * Build : Generates Android.bp and types.hal.h

```plantUML
skinparam DefaultTextAlignment center
skinparam defaultFontSize 13

actor User as user
participant "build.sh" as buildsh
participant "generate_bp.sh" as generatebpsh
participant "cmake" as cmake
participant "make_hal_to_header.sh" as makehal


user -> buildsh: build.sh
buildsh -> generatebpsh: ./generate_bp.sh
generatebpsh -> cmake
generatebpsh -> makehal: call make_hal_to_header.sh
makehal -> makehal: generate types.hal.h

```

#### * enn_initialize()
```plantUML
skinparam DefaultTextAlignment center
skinparam defaultFontSize 13

actor User as user
participant "enn_api.cc" as ennapi
participant "EnnContext" as context
participant "EnnMediumInterface" as emif
participant "EnnInterface(HIDL - client)" as eif1
participant "EnnInterface(HIDL - service)" as eif2
participant "CoreEngine" as engine

user->ennapi: enn_initialize()
ennapi->context: init()
context->emif: init()

group HIDL build
emif->eif1: init()
eif1-->eif2: init()
eif2->engine: init()
engine->UserDrivers: init h/w
engine-->eif2: return
eif2-->eif1: return
eif1-->emif: return
end

group lib build
emif->engine: init()
engine->UserDrivers: init h/w
engine-->emif: return
end

emif-->context: return
context-->ennapi: return
```


### Related Files
* enn_api.cc
```c++
EnnReturn EnnOpenModel(const char *model_file, EnnModelId *model_id, const EnnModelPreference &preference)
```
* enn_medium_interface.cc
```c++
// hidl case
HIDL_IF(android::sp<IEnnInterface> service);
HIDL_IF(service->open_model({buf->get_native_handle(), buf->size, attr, reinterpret_cast<uint64_t>(buf->va), {}},
                            [&](SessionBufInfo info) { *ret_info = info; }));
// lib case
LIB_IF(::enn::runtime::Engine* service);
LIB_IF(service->open_model({.data = {.numFds = 1, {buf->fd}, buf->va},
                            .size = buf->size,
                            .attr = attr,
                            .va = reinterpret_cast<uint64_t>(buf->va)},
                            ret_info.get()));
```
* IEnnInterface.hal
```c++
open_model(LoadParameter load_param) generates (SessionBufInfo sbi_ret);
```
* types.hal
```c++
struct Buffer {
    uint32_t region_idx;
    DirType dir;
    uint32_t buf_index;
    uint32_t size;
    uint32_t offset;
    ShapeInfo shape;   // n x w x h x c
    uint32_t buffer_type;
    string name;
    vec<uint32_t> reserved;
};

struct Region {
    uint32_t attr;   // MANDATORY, IS_FD, header will define this.
    uint32_t req_size;
    string name;
    vec<uint32_t> reserved;
};

struct SessionBufInfo {
    uint64_t model_id;   // model_id should be over 1. model_id = 0 means error from service
    vec<Buffer> buffers;
    vec<Region> regions;
};
```
* EnnInterface.cpp
```c++
Return<void> EnnInterface::open_model(
        const ::vendor::samsung_slsi::hardware::enn::V1_0::LoadParameter& load_param, open_model_cb _hidl_cb) {
    ::vendor::samsung_slsi::hardware::enn::V1_0::SessionBufInfo test;

    ::enn::runtime::Engine::get_instance()->open_model(load_param, &test);  // Engine은 singleton pattern. test의 sp를 보냄
    _hidl_cb(test);
    // return으로 callback function 불러서 저장
    // 참고 코드(위) : [&](SessionBufInfo info) { *ret_info = info; }

    return Void();
}
```

* engine.cc
```c++
Engine::ModelId Engine::open_model(const LoadParameter& load_param, SessionBufInfo *session_info) {
    return impl_->open_model(load_param, session_info);
}
```
